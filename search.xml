<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构(Java版)</title>
      <link href="/2022/12011560.html"/>
      <url>/2022/12011560.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第一章、绪论"><a href="#第一章、绪论" class="headerlink" title="第一章、绪论"></a>第一章、绪论</h2><h3 id="0-0"><a href="#0-0" class="headerlink" title="0.0"></a>0.0</h3><p>&ensp; 这里所分享的数据结构知识只是帮助小白了解基础知识，帮助同胞可以方便的考过期末考试。想要具体深入研究的，可自行上网寻找相关视频学习。本人也是学生，如果文中有错，请各位在下面的评论中指出，总结下面知识，不是为了去营销~~~~</p><h3 id="1-1、数据结构的基本概念"><a href="#1-1、数据结构的基本概念" class="headerlink" title="1.1、数据结构的基本概念"></a>1.1、数据结构的基本概念</h3><ol><li><strong>数据</strong>：描述客观事物的数、字符以及所有能输入计算机中被计算机程序处理的符号的集合</li><li><strong>数据元素</strong>：是数据的基本单位，通常作为一个整体进行考虑和处理(<font color=red>例如：一个班级中的每个学生就是一个数据元素)。</font>一个数据元素可由若干个数据项组成。数据项是构成数据元素的不可分割的最小单位。</li><li><strong>数据对象</strong>：性质相同的有限个数据元素的集合，它是数据的一个子集。在默认情况下，数据结构中的数据都是指的数据对象。</li><li><strong>数据结构</strong>：所涉及的数据元素的集合以及数据元素之间的关系。因此可以把数据结构看成是带结构的数据元素的集合。数据结构包括如下几个方面：<ol><li><font color=red>数据元素之间的<font style="background:#FFF123">逻辑关系</font>，即数据的逻辑结构，它是数据结构在用户面前呈现的形式</li><li>数据元素及关系在计算机存储器中的存储方式，即数据的<font style="background:#FFF123">存储结构</font>，也叫数据的物理结构</li><li>施加在该数据上的操作，即<font style="background:#FFF123">数据的运算</font></font><h3 id="1-2、数据结构的三要素"><a href="#1-2、数据结构的三要素" class="headerlink" title="1.2、数据结构的三要素"></a>1.2、数据结构的三要素</h3></li></ol></li><li><strong>数据的逻辑结构</strong>：  </li></ol><ul><li>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据,是面向用户的，是独立于计算机的</li><li>逻辑结构包括：<ul><li>集合结构：结构中的数据元素之间除”同属一个集合”外，无其他关系；</li><li>线性结构：结构中数据元素之间只存在一对一的关系，除了第一个元素，所有元素都有唯一的前驱。除了最后一个元素，所有元素都有唯一的后继；</li><li>树形结构：结构中数据元素之间存在一对多的关系；</li><li>图形结构：数据元素之间存在多对多的关系；  </li></ul></li></ul><ol start="2"><li><strong>数据的物理(存储)结构</strong>：<br>存储结构是指数据结构在计算机中的表示(又称映射)，也称物理结构。存储结构包括如下：<ol><li>顺序存储：把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现；</li><li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系；</li><li>索引存储：在存储元素信息的同时，还建立附加的索引表，索引表中的每项称为索引项。</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储；</li></ol></li><li><strong>数据的运算</strong>：施加在数据上的运算包括运算的定义。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤</li><li>图解：<img src="imgs/../../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><h3 id="1-3、算法的基本概念"><a href="#1-3、算法的基本概念" class="headerlink" title="1.3、算法的基本概念"></a>1.3、算法的基本概念</h3></li><li>程序=数据结构+算法</li><li><strong>算法</strong>是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作；</li><li><strong>算法的特征</strong>：<ol><li><strong>有穷性</strong>：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li><strong>确定性</strong>：算法中每条指令必须有确定的含义，对于相同的输入只能得到相同的输出。</li><li><strong>可行性</strong>：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li><li><strong>输入</strong>：一个算法<em><strong>有零个或多个输入</strong></em>，这些输入取自于某个特定的对象的集合。</li><li><strong>输出</strong>：一个算法有一个多个输出，这些输出是与输入有着某种特定关系的量。</li></ol></li><li>好的算法达到的目标：<ol><li><strong>正确性</strong>：要求算法能够正确的执行预先规定的功能和性能要求。<font color=red>这是最重要的也是最基础的。</font></li><li><strong>可使用性</strong>:要求算法恩能够很方便的使用</li><li><strong>可读性</strong>：算法应该易于人们理解，也就是可读性好。为了达到这个要求，算法的逻辑必须清晰的、简单的和结构化的。</li><li><strong>健壮性</strong>：要求算法具有很好的容错性，即提供异常处理，能够对不合理的数据进行检查，不进常出现异常中断或四级现象</li></ol></li><li>算法的时间复杂度<ol><li>指执行算法所需要的计算工作量；</li><li>一个算法花费的时间与算法中语句执行次数成比例。一个算法中的语句执行次数为时间频度，记为：T(n)</li><li><font color=red>大O表示法：用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。</font></li><li>一些常见的大O运行时间：<ol><li>O(log n)，对数时间，二分查找。</li><li>O(n)，线性时间，简单查找。</li><li>O(n logn)，快速排序——速度较快的排序算法。</li><li> O(n²)，选择排序——速度较慢的排序算法。</li></ol></li><li>个复杂度比较，越小越好：log2n以2为底<ol><li>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n*n)&lt;O(2^n)&lt;O(n!)</li></ol></li></ol></li><li>算法的空间复杂度<ol><li>对算法在运行过程中临时占用存储空间大小；</li></ol></li><li>算法的评估标准：就是算法占用计算机资源的多少</li></ol><h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="2-1、线性表的定义："><a href="#2-1、线性表的定义：" class="headerlink" title="2.1、线性表的定义："></a>2.1、线性表的定义：</h3><p>&ensp; 线性表是一种典型的线性结构，也是最常用的一种数据结构。具有相同数据类型的n(n&gt;0)个数据元素的有限序列，其中n为表长，当n=0时，线性表是一个空表;</p><h3 id="2-2、线性表的顺序存储结构-—-顺序表"><a href="#2-2、线性表的顺序存储结构-—-顺序表" class="headerlink" title="2.2、线性表的顺序存储结构 — 顺序表"></a>2.2、线性表的顺序存储结构 — 顺序表</h3><pre class=" language-JAVA"><code class="language-JAVA">class SqListClass<E> &#123;    final int initcapacity = 10; //初始表的容量    public E[] data; //存放元素的数组    public int size; //表中的元素个数    private int caption;//存放表的容量,就是当前表的容量    //初始化表中属性    public SqListClass() &#123;        data = (E[]) new Object[initcapacity];        caption = initcapacity;        size = 0;    &#125;    // 动态的分配空间    public void UpdataCapacity(int newCapacity) &#123;        E[] newData = (E[]) new Object[newCapacity];        // data中元素原封不动的放到新的数组中        for (int i = 0; i < data.length; i++) &#123;            newData[i] = data[i];        &#125;        caption=newCapacity;//获取当前表的容量        data=newData;// 仍有data标识数组    &#125;    //将一个数组元素插入到data数组中。算法复杂度：O(n)    public void CreateList(E[] a)&#123;        for (int i = 0; i < a.length; i++) &#123;            // 出现上溢的情况            if(size == caption)&#123;                UpdataCapacity( 2*size );            &#125;            data[size++]=a[i];        &#125;    &#125;    // 表的基本运算:添加.算法复杂度：O(1)    public void Add(E a)&#123;        if(size==caption)&#123;            UpdataCapacity( 2*size );        &#125;        data[size++]=a;    &#125;    // 表的长度    public int size()&#123;        return size;    &#125;    // 设置表的长度：目的为了缩小空间.算法复杂度：O(1)    public void SetSize(int nlen)&#123;        if(nlen<0 || nlen>size)&#123;            throw new IllegalArgumentException("设置长度：n不在有限的范围之内");        &#125;        size=nlen;    &#125;    // 查找：求表中序号为i的元素.算法复杂度：O(1)    public E GetElem(int i)&#123;        if(i<0 || i>size-1)&#123;            throw new IllegalArgumentException("查找元素：i不在有限的范围之内");        &#125;        return data[i];    &#125;    //更新：设置下标为i上的值.算法复杂度：O(1)    public void SetElem(int i,E e)&#123;        if(i<0 || i>size-1)&#123;            throw new IllegalArgumentException("查找元素：i不在有限的范围之内");        &#125;        data[i]=e;    &#125;    // 查找第一个元素为e的下标.算法复杂度：O(n)    public int GetElem(E e)&#123;        for (int j = 0; j < size-1; j++) &#123;            if(data[j].equals( e ))&#123;                return j;            &#125;        &#125;        return -1;    &#125;    //data数组通过下标交换两个元素    public void Swap(int i,int j)&#123;        if((i<0 || i>size-1) || (j<0 || j>size-1))&#123;            throw new IllegalArgumentException("查找元素：i或j不在有限的范围之内");        &#125;        E temp=data[i];        data[i]=data[j];        data[j]=temp;    &#125;    //在下标为 i 的位置插入元素.算法复杂度：O(n)    public void InsertElem(int i,E e)&#123;        if(i<0 || i>size)&#123;            throw new IllegalArgumentException("查找元素：i不在有限的范围之内");        &#125;        if(size==caption)&#123;            UpdataCapacity( 2*size );        &#125;        for (int j = size; j >i; j--) &#123;            data[j] = data[j-1];        &#125;        data[i]=e;        size++;    &#125;    // 删除位置为i 的元素.算法复杂度：O(n)    public void Delete(int i)&#123;        if(i<0 || i>size-1)&#123;            throw new IllegalArgumentException("查找元素：i不在有限的范围之内");        &#125;        for (int j = i; j < size-1; j++) &#123;            data[i]=data[i+1];        &#125;        size--;        // 满足要求，容量减半        if(caption>initcapacity && size==caption/4)&#123;            UpdataCapacity( caption/2 );        &#125;    &#125;&#125;</code></pre><h3 id="2-3、线性表的特点："><a href="#2-3、线性表的特点：" class="headerlink" title="2.3、线性表的特点："></a>2.3、线性表的特点：</h3><ol><li><font color=red>随机访问(随机存取)，</font>可以在O(1)时间内找到第i个元素</li><li>存储密度高，每个节点只存储数据元素</li><li>扩展容量方便</li><li><font color=red>插入、删除操作不方便，</font>需要移动大量元素</li></ol><h3 id="2-4、线性表的链表存储-—-链表："><a href="#2-4、线性表的链表存储-—-链表：" class="headerlink" title="2.4、线性表的链表存储 — 链表："></a>2.4、线性表的链表存储 — 链表：</h3><ol><li><p>链表的定义：一个节点中不仅包含元素本身的信息，还包含后继或前驱结点的信息。</p></li><li><p>如果每个结点只设置了一个指向后继结点的指针成员，称为单链表。当访问过一个结点后，只能接着访问后面的后继结点，无法访问它的前驱结点。</p></li><li><p>如果每个结点设置了一个指向后继结点和一个指向前驱节点的指针成员，称为双链表。当访问过一个结点后，可以一次访问后继或前驱结点。</p></li><li><p><font color=red>这里需要注意的是，头结点和首(开始)结点不同，头结点为null，通常不存放任何元素，首结点为第一个元素。</font></p></li><li><p><font style="background:#ffff22">单向链表不可以 自我删除，在添加和删除的时候都要找到要操作结点的前一个结点</font></p></li><li><p><em><strong>单链表</strong></em>的添加和删除：</p><pre class=" language-JAVA"><code class="language-JAVA">// 单链表的结点 class LinkNode<E> &#123;     E data;// 数据成员     LinkNode next; //指向的结点地址     public LinkNode() &#123;         next = null;     &#125;     public LinkNode(E e) &#123;         data = e;         next = null;     &#125; &#125; // 设置单链表类 class LinkListClass<E> &#123;     LinkNode<E> head; // 存放头结点     public LinkListClass() &#123;         head = new LinkNode<E>(); // 创建头结点         head.next = null; // 头结点next为null     &#125;     // 使用头插法建表,每次都是从第一个元素插入，所以最后结果是倒叙     public void CreateListF(E[] a) &#123; // 由数组a整体建立单链表         LinkNode<E> s; // 插入的结点 的对象         for (int i = 0; i < a.length; i++) &#123;             s = new LinkNode<>( a[i] );             s.next = head.next;             head.next = s;         &#125;     &#125;     // 使用尾插法建表。这里需要知道，结点是不可以动的，只可以代替，这里t就是为了代替结点。时间复杂度O(n)     public void CreateListR(E[] a) &#123;         LinkNode<E> s,t; // 插入的结点 的对象         t=head;         for (int i = 0; i < a.length; i++) &#123;             s=new LinkNode<>(a[i]);             s.next=t.next; //s的指针指向t.next的结点             t=s; // t替换为s结点         &#125;         t.next=null;     &#125;     // 返回序号为i的结点,单链表只可以从头结点开始一个一个向后面找元素     public LinkNode<E> geti(int i)&#123;         LinkNode p=head;         int j=-1;         while (j<i)&#123;             j++;             p=p.next;         &#125;         return p;     &#125;     //获取链表结点的个数     public int size()&#123;         LinkNode p=head;         int sum=0;         while (p.next !=null)&#123;             sum++;             p=p.next;         &#125;         return sum;     &#125;     //删除第几个序号的结点     public void Delte(int i)&#123;         if(i<0 || i>size()-1)&#123;             throw new IllegalArgumentException("找出结点：i的范围出错");         &#125;         LinkNode p=geti( i-1 );         p.next=p.next.next;     &#125; &#125;</code></pre><h3 id="2-5、双链表"><a href="#2-5、双链表" class="headerlink" title="2.5、双链表"></a>2.5、双链表</h3></li><li><p>双链表中每个结点有两个指针成员，一个指向后继结点，一个指向前驱结点。   </p></li></ol><p><em><strong>双链表的相关操作</strong></em>：</p><pre class=" language-Java"><code class="language-Java">    class DLinkNode<E> &#123; //双链表结点泛型类        E data; //结点元素值        DLinkNode<E> prior; //前驱结点指针        DLinkNode<E> next; //后继结点指针        public DLinkNode() &#123;            prior = null;            next = null;        &#125;        public DLinkNode(E data) &#123;            this.data = data;            prior = null;            next = null;        &#125;    &#125;    class DLinkListClass<E> &#123; //双链表泛型类        DLinkNode<E> dhead; // 存放头结点        public DLinkListClass() &#123;            dhead = new DLinkNode<>();            dhead.prior = null;            dhead.next = null;        &#125;        // 使用尾插法建表        public void CreateListR(E[] a) &#123;            DLinkNode<E> s, t;            t = dhead; // 这里解释一下：链表中的结点是不可以移动的，所以需要使用所谓的'替身'            for (int i = 0; i < a.length; i++) &#123;                s = new DLinkNode<>( a[i] );                t.next = s; //t的后继结点指向s                s.prior = t; // s的前驱结点指向t                t = s; //t 替换 s            &#125;            t.next = null; //将尾结点的next成员设置为null        &#125;        // 双链表的长度        public int size() &#123;            DLinkNode<E> t;            t = dhead;            int sum = 0;            while (t.next != null) &#123;                sum++;                t = t.next;            &#125;            return sum;        &#125;        // 双链表的指定元素,这里的i是序号，从0开始        public DLinkNode geti(int i) &#123;            DLinkNode p = dhead;            int j = -1;            while (j < i) &#123;                j++;                p = p.next;            &#125;            return p;        &#125;        // 在双链表中插入元素        public void Insert(int i, E e) &#123; // 在序号为i的位置上插入元素            if (i < 0 || i > size()) &#123;                throw new IllegalArgumentException( "插入：位置i不在有效范围内" );            &#125;            DLinkNode s = new DLinkNode( e );//建立新的结点            DLinkNode p = geti( i - 1 ); //找到序号为i-1的元素，在其后面加入新的元素s            s.next = p.next;            if (p.next != null) &#123; // 判断p结点是否有后继结点                p.next.prior = s;            &#125;            p.next = s; //p的后继结点指向s            s.prior = p;// s的前驱结点指向p        &#125;        // 删除结点        public void Delete(int i) &#123;            if (i < 0 || i > size() - 1) &#123;                throw new IllegalArgumentException( "删除：位置i不在有效范围内" );            &#125;            DLinkNode p = geti( i );// 找到指定的元素            if (p.next != null) &#123;                p.next.prior = p.prior;            &#125;            p.prior.next = p.next;        &#125;        // 以上两种算法的时间复杂度都是O(n)    &#125;</code></pre><h3 id="2-6、单链表和双链表的区分"><a href="#2-6、单链表和双链表的区分" class="headerlink" title="2.6、单链表和双链表的区分"></a>2.6、单链表和双链表的区分</h3><ol><li><p>在单链表中删除一个结点需要找到其前驱结点，而在双链表中删除结点不必找到其前驱结点，在需要找到要删除的结点即可。</p><h3 id="2-7、循环链表"><a href="#2-7、循环链表" class="headerlink" title="2.7、循环链表"></a>2.7、循环链表</h3></li><li><p>介绍：循环链表时另一种形式的链式存储结构，分为循环单链表和循环双链表两种形式，分别是从单链表和双链表变化而来。</p></li><li><p><em><strong>循环单链表</strong></em>：</p><ol><li><p>表中尾结点的next指针域不再是null,而是指向头结点，从而整个链表形成一个首尾相接的表。</p></li><li><p>特点：从表中的任一结点出发都可以找到其他节点，与单链表相比，无须增加存储空间。默认情况下，循环单链表也是通过头结点head标识的。</p><pre class=" language-Java"><code class="language-Java">class LinkListClass<E> &#123;  LinkNode<E> head; // 存放头结点  public LinkListClass() &#123;      head = new LinkNode<E>(); // 创建头结点      head.next = head; // 置为空的循环单链表  &#125;&#125;</code></pre></li><li><p>循环单链表的插入和删除与单链表的相同，所以两者的许多基本运算算法是相似的，只要区别就是：</p><ol><li>初始只有头结点head,在循环单链表的构造方法中国需要通过head.next=head语句置为空表。</li><li>循环单链表中涉及查找操作时需要修改表尾的判断的条件。比如在遍历链表时，尾结点满足的条件是p.next==head。</li></ol></li></ol></li><li><p><em><strong>循环双链表</strong></em>：</p><ol><li><p>尾结点的指针指向头结点，头结点的prior指针指向尾结点。其特点就是表成为两个环。</p></li><li><p>特点：从表中任意一个结点出发均可以找到其他节点。通过头结点在O(1)时间内找到尾结点。</p></li><li><p>循环双链表的插入和删除与双链表的相同，所以两者的许多基本运算算法是相似的，只要区别就是：</p><ol><li>初始只有头结点head,在循环双链表的构造方法中国需要通过dhead.prior=head和dhead.next = dhead语句置为空表。</li></ol></li><li><p>循环双链表中涉及查找操作时需要修改表尾的判断的条件。比如在遍历链表时，尾结点满足的条件是p.next==head。</p><pre class=" language-Java"><code class="language-Java">class DLinkListClass<E> &#123; //双链表泛型类    DLinkNode<E> dhead; // 存放头结点    public DLinkListClass() &#123;        dhead = new DLinkNode<>();        dhead.prior = dhead;        dhead.next = dhead;    &#125;&#125;</code></pre></li></ol></li></ol><h3 id="2-8、顺序表和链表的比较"><a href="#2-8、顺序表和链表的比较" class="headerlink" title="2.8、顺序表和链表的比较"></a>2.8、顺序表和链表的比较</h3><ol><li>逻辑结构<ol><li>顺序表和链表都属于线性表，都是线性结构</li></ol></li><li>存储结构<ol><li>顺序表：顺序存储<ol><li>优点：支持随机存取，存储密度高</li><li>缺点：大片连续空间分配方便，改变容量不方便</li></ol></li><li>链表：链式存储<ol><li>优点：离散的小空间分配方便，改变容量方便</li><li>缺点：不可随机存取，存储密度低</li></ol></li></ol></li><li>总结： <font style="background:#ffff22">一般情况下，存储密度越高，空间利用率越高。仅从存储密度看，顺序表的存储空间利用率高。</font>。<ol><li>从空间方面看：顺序表需要预先分配连续的内存空间，容易出现上溢情况，需要扩展空间，会导致大量元素移动，效率低；链表的存储空间是动态分配的，只要内存有空间，就不会出现上溢。</li><li>从时间方面看：线性表的运算只要就是查找，很少做插入或删除操作，所以宜使用顺序表作为存储结构。</li></ol></li></ol><h2 id="第三章：栈和队列-Stack-and-Queue"><a href="#第三章：栈和队列-Stack-and-Queue" class="headerlink" title="第三章：栈和队列(Stack and Queue)"></a>第三章：栈和队列(Stack and Queue)</h2><h3 id="3-1、栈-Stack"><a href="#3-1、栈-Stack" class="headerlink" title="3.1、栈(Stack)"></a>3.1、栈(Stack)</h3><ol><li>栈的定义：<ul><li>栈是特殊的线性表：只允许在一端进行插入或删除操作，其逻辑结构与普通的线性表相同;</li><li>栈顶(Top):允许进行插入和删除的一端(最上面的为栈顶元素)；</li><li>栈底(Bottom): 固定的，不允许进行插入和删除的一端(最下面的为栈底元素)；</li><li>空栈：不含任何元素的空表；</li><li>特点：先进后出、后进先出；</li><li>缺点：栈的大小不可变；<h3 id="3-2、栈的顺序存储结构及操作"><a href="#3-2、栈的顺序存储结构及操作" class="headerlink" title="3.2、栈的顺序存储结构及操作"></a>3.2、栈的顺序存储结构及操作</h3></li></ul></li><li>顺序栈的四要素：<ol><li>栈空的条件为top == -1;</li><li>栈满(栈上溢出)的条件为top == capacity-1,我们采用动态扩展容量方式，即栈满时，数组容量扩大两倍;</li><li>元素e进栈操作是先将栈顶指针top增1，然后再将元素e放在栈顶指针处;</li><li>出栈操作是先将栈顶指针top处的元素取出，然后将栈顶指针减1  </li></ol></li></ol><blockquote><p>这里我们区分一下正栈和倒栈的区别:<br>栈的存储空间S(1:m),可以理解Wie一个可以容纳m个数据的空间，本身看不出方法的，因此要根据数据进出栈时的指针变化来区分正栈和倒栈。<br>正栈：栈底为1，栈顶可以为1~m中任意一个数，但是top=m时，栈满，top不可能指向大于m的任何数字。此时，栈中的元素为top-bottom+1;，对于正栈，栈空的时候top可以为0、-1、···中任意一个数，可以理解每出一个栈，栈顶指针top-1,直到top=0，栈为空。</p><ul><li>特点：<font style="background:#ffff22">元素入栈：先将top值自增1，然后元素入栈，放在top指针处。data[++top]=e。自己的理解：想要在栈中添加一个数据，首先得知道栈中的容量够不够，如果直接塞进去，容量不够就会被挤出来，所以栈顶元素得先自增1，如果容量不过，则动态去扩展容量，这样就防止溢出。<font></li><li>出栈操作：<font color=red>先将top指针的元素取出，然后栈顶指针再减1。e=data[top–]。这个就比较直接了当了，比如当我们在一摞书上，首先是先咋走一本书，总体书的数量才会再减1，不可能你都没有拿书，就开始减1吧。</font></li></ul><p>倒栈： 初始状态下栈顶为m，栈底为m，当top=1时表示栈满，top不可能指向小于1的任何数。此时，栈中的元素数量等于m-top。可以理解为每出栈一个元素，top++，直到top=m+1,栈空。</p><ul><li>特点：元素入栈：先将元素入栈，然后top值自减1，放在top指针处。data[top–]=e。</li><li>元素出栈：先将栈顶自增1，然后元素出栈。</li></ul></blockquote><blockquote><p>总结：</p><ul><li>正栈 入栈：先增后入</li><li>正栈 出栈：先出后减</li><li>倒栈 入栈：先入后减</li><li>倒栈 出栈：先增后出</li></ul></blockquote><pre class=" language-Java"><code class="language-Java">class SqStackClass<E> &#123; // 顺序栈泛型类    final int initcapacity = 10; // 初始栈的容量    private int capacity; // 存放顺序栈的容量    private E[] data; // 存放顺序栈的元素    private int top; // 存放栈顶的指针    public SqStackClass() &#123;        data = (E[]) new Object[initcapacity];        capacity = initcapacity;        top = -1;    &#125;    public void UpdateCapacity(int newCapacity) &#123; // 改变顺序栈的容量        E[] newdata = (E[]) new Object[newCapacity];        for (int i = 0; i <= top; i++) &#123;            newdata[i] = data[i];        &#125;        capacity = newCapacity;        data = newdata;    &#125;    public boolean IsEmpty() &#123; // 判断栈是否为空        return top == -1;    &#125;    public void push(E e) &#123; // 元素进栈        if (top == capacity) &#123;            UpdateCapacity( 2 * (top + 1) );        &#125;        top++;        data[top] = e;    &#125;    public E pop()&#123; // 出栈操作        if(IsEmpty())&#123;            throw new IllegalArgumentException("栈空");        &#125;        E e=data[top];        top--;        return e;    &#125;    public E peek()&#123;        if(IsEmpty())&#123;            throw new IllegalArgumentException("栈空");        &#125;        return data[top];    &#125;    // 从上面的算法来看，所有的操作时间复杂度都是O(1)&#125;</code></pre><h3 id="3-3、栈的链式存储结构及操作"><a href="#3-3、栈的链式存储结构及操作" class="headerlink" title="3.3、栈的链式存储结构及操作"></a>3.3、栈的链式存储结构及操作</h3><ol><li><p>定义：采用链式存储的栈称为链栈</p></li><li><p>优点：便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况。</p></li><li><p>特点：</p><ol><li>进栈和出栈都只能在栈顶一端进行(链头作为栈顶)</li></ol></li><li><p>所以，链栈实际就是一个只能采用头插法插入或删除数据的链表。<br>```Java<br>// 在此说明一下，结点类在前面的单链表中定义过了。<br>class LinkStackClass<E> {<br> LinkNode<E> head;</p><p> public LinkStackClass() {</p><pre><code> head = new LinkNode&lt;&gt;(); head.next = null;</code></pre><p> }</p><p> public boolean empty() { // 判断链栈是否为空</p><pre><code> return head.next == null;</code></pre><p> }</p><p> public void push(E e) { // 入栈</p><pre><code> LinkNode s = new LinkNode(); s.next = head.next; head.next = s;</code></pre><p> }</p><p> public E pop() { // 出栈</p><pre><code> if (empty()) &#123;     throw new IllegalArgumentException( &quot;栈空&quot; ); &#125; E e = (E) head.next.data; head.next = head.next.next; return e;</code></pre><p> }</p><p> public E peek() { // 取栈顶元素</p><pre><code> if (empty()) &#123;     throw new IllegalArgumentException( &quot;栈空&quot; ); &#125; return (E) head.next.data;</code></pre><p> }</p></li></ol><p>}</p><pre><code>5. 栈的基本操作：   1. 初始化   2. 进栈   3. 出栈   4. 栈满、栈空   5. 判断栈顶的元素### 3.4、队列(Queue)1. 定义：队列简称对，是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。2. 特点：   1. 操作特性：先进先出   2. 队头：允许删除的一端   3. 队尾：允许插入的一端   4. 空队列：不含任何元素的空表### 3.5、队列的顺序存储结构及操作1. 顺序队分为非循环队和循环队两种方式。首先我们先说非循环队及特征2. 默认初始值front和rear均为 -13. 队头指针为front(实际上是对头元素的前一个位置)，队尾指针为rear(正好是队尾元素的位置).为什么让front指向队列中前一个元素位置？因为在front增1后，该位置的元素已经出队了4. 队满：rear == MaxSize-15. 元素每次进队：rear = rear+1(队尾先+1，再入队)6. 元素每次出队：front = front+1(队头先+1，再出队)7. 队空的条件：front == rear8. &lt;font style=&quot;background:#ffff22&quot;&gt;特点：非循环队列会出现假溢出。相关操作的时间复杂度都是O(1)&lt;/font&gt;```Javaclass SqQueueClass&lt;E&gt; &#123; // 非循环队列的泛型类    final int MaxSize = 10; // 假设容量为10    private E[] data; // 存放队列中的元素    private int front, rear; // 队头、队尾的指针    public SqQueueClass() &#123;        data = (E[]) new Object[MaxSize];        front = rear = -1; // 队头、队尾的指针默认为-1，队为空    &#125;    public boolean empty() &#123; // 判断是否为空        return front == rear;    &#125;    public void push(E e) &#123; // 入队操作        if (rear == MaxSize - 1) &#123;            throw new IllegalArgumentException( &quot;队满&quot; );        &#125;        rear++;        data[rear] = e;    &#125;    public E pop() &#123; // 出队        if (front == rear) &#123;            throw new IllegalArgumentException( &quot;队空&quot; );        &#125;        front++;        E e = data[front];        return e;    &#125;    public E peek() &#123; // 取头元素        if (front == rear) &#123;            throw new IllegalArgumentException( &quot;队空&quot; );        &#125;        return data[front + 1];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础三</title>
      <link href="/2022/110638825.html"/>
      <url>/2022/110638825.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础三"><a href="#Java基础三" class="headerlink" title="Java基础三"></a>Java基础三</h1><h2 id="一、类的成员之四：代码块"><a href="#一、类的成员之四：代码块" class="headerlink" title="一、类的成员之四：代码块"></a>一、类的成员之四：代码块</h2><h3 id="认识代码块-Block"><a href="#认识代码块-Block" class="headerlink" title="认识代码块(Block)"></a>认识代码块(Block)</h3><ol><li><p>Block的作用：初始化类、对象</p></li><li><p>格式：在类中就是一个大括号{}或者static{},当然我们可以看做是一个方法</p></li><li><p>Block<font color=red>如果有修饰的话，只能使用static</font></p><h3 id="Block的分类"><a href="#Block的分类" class="headerlink" title="Block的分类"></a>Block的分类</h3></li><li><p>静态Block(static{})</p><ol><li>内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次，执行顺序总是第一个执行</li><li>作用：初始化类的信息</li><li>如果一个类中定义了多个静态代码块,则按出现的顺序执行</li></ol></li><li><p>非静态Block({})</p><ol><li> 内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次，执行顺序总是第一个执行</li><li>每创建一个对象，就执行一次非静态Block</li><li>如果一个类中定义了多个静态代码块,则按出现的顺序执行</li></ol></li></ol><blockquote><p>总结：对<font style="background: #ffff55">属性赋值的位置</font>优先顺序：</p><ol><li>默认初始化</li><li>显示初始化</li><li>构造器中初始化</li><li>对象实例化中”对象.属性”或者”对象.方法()”</li><li>使用代码块  </li></ol><p><font style="background: #ffff55">执行顺序：1 -&gt; 2/5 -&gt; 3 -&gt; 4;2/5顺序看哪一个写在前面</font></p></blockquote><h2 id="二、类的成员之五：内部类-了解"><a href="#二、类的成员之五：内部类-了解" class="headerlink" title="二、类的成员之五：内部类(了解)"></a>二、类的成员之五：内部类(了解)</h2><p>由于内部类不是常用的成员，所以大家就大致的了解一下就OK了</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;在Java中，允许一个类A的定义位于另一个类B的内部，A称为内部类，B称为外部类。 </p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>&emsp;成员内部类 （静态内部类、非静态内部类）vs 局部内部类（方法内、构造器内、代码块内);  </p><ol><li><p>成员内部类作为类的成员的角色：</p><ul><li>和外部类不同，Inner class还可以声明为private或protected；</li><li>可以调用外部类的结构</li><li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员<br>变量；  </li></ul></li><li><p>成员内部类作为类的角色：</p><ol><li>可以在内部定义属性、方法、构造器等结构</li><li>可以声明为abstract类 ，因此可以被其它的内部类继承</li><li>可以声明为final的</li><li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li></ol></li><li><p>注意：</p><ul><li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员 内部类中才可声明static成员。</li><li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 </li><li>成员内部类可以直接使用外部类的所有成员，包括私有的数据 ；当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态</li></ul></li></ol><h2 id="三、Object类的介绍"><a href="#三、Object类的介绍" class="headerlink" title="三、Object类的介绍"></a>三、Object类的介绍</h2><h3 id="Object的说明"><a href="#Object的说明" class="headerlink" title="Object的说明"></a>Object的说明</h3><ol><li>Object类是Java中所有类的根父类</li><li>如果我们没有声明一个类继承父类，则此类默认继承java.lang.Object类</li><li>所有的java类（除了java.lang.Object类之外）都直接或间接继承java.lang.Object类,意味着所有Java类都具有java.lang.Object类声明的功能</li><li><font style="background: #ffff55">Object只声明了一个空参构造器</font><h3 id="Object中部分方法"><a href="#Object中部分方法" class="headerlink" title="Object中部分方法"></a>Object中部分方法</h3></li><li>equals();</li><li>toString():<ol><li>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()。(如果自定义类不重写toString(),则输出地址值)</li><li>Object类中toString()的定义：<ol><li>public String toString(){return getClass.getName()+”@”+Integer.toHexString(hashCode())}; 获取虚拟地址值。所以需要重写该方法</li><li><font style="background: #ffff55">特别的：像String 、Date、File、包装类等都重写了Object类中的toString()方法。重写以后，使得在调用对象tostring()方法时，返回“实体内容”信息。</font></li></ol></li></ol></li></ol><h2 id="四、-和-equals-的区别-非常重要"><a href="#四、-和-equals-的区别-非常重要" class="headerlink" title="四、== 和 equals()的区别(非常重要)"></a>四、== 和 equals()的区别(非常重要)</h2><ol><li><p>== 的使用：</p><ol><li>== 为运算法<ol><li>可以使用在基本数据类型变量和引用数据类型变量中</li><li>可以比较的是基本数据类型变量：比较两个变量保存的数据是否相同</li><li>如果比较的是引用数据类型变量：比较的是两个对象的地址值是否相同(这里需要知道的是，每new一个对象，地址值都是重新赋一个16进制数。特殊的String类中，具体在后面文章)。</li></ol></li></ol></li><li><p>equals()方法的使用：</p><ol><li><p>equals():是一个方法而不是运算法</p><ol><li>所以只能引用数据类型</li></ol></li><li><p>Object类中equals()的定义：</p><ol><li>public boolean equals(Object obj){return this == obj;}   </li><li>Object类中equals()的定义和 == 中引用数据类型的作用相同：比较的是两个对象的地址值是否相同</li></ol></li><li><p>像Strign、Date、File、包装类等都重写了Object类中的equals()方法，所以比较的就不再是地址值是否相同，而是比较的是两个对象的 “实体内容”是否相同</p></li><li><p>通常情况下，我们自定义的类如果使用equals()方法的话，也通常是比较两个对象的实体内容是否相同，所有我们要对Object类中equals()方法进行重写</p></li></ol></li></ol><h2 id="五、重写-override"><a href="#五、重写-override" class="headerlink" title="五、重写(override)"></a>五、重写(override)</h2><h3 id="override的介绍"><a href="#override的介绍" class="headerlink" title="override的介绍"></a>override的介绍</h3><ol><li><p>子类继承父类之后，可以对父类中同名同参数的方法进行覆盖操作</p></li><li><p>覆盖之后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类中的方法</p><h3 id="override的规定："><a href="#override的规定：" class="headerlink" title="override的规定："></a>override的规定：</h3></li><li><p>方法声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常类型{方法体}</p></li><li><p>规定俗称：</p><ol><li><p>子类中的叫重写方法，父类中叫被重写方法</p></li><li><p><font style="background: #ffff55">子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</font></p></li><li><p>子类重写的方法的修饰符不小于父类被重写的方法的权限修饰符（子类的修饰符范围更大）</p><ul><li><font style="background: #ffff55">特殊情况：子类不能重写父类中声明为private权限的方法&lt;/font</li></ul></li><li><p>返回值类型</p><ol><li>父类被重写的方法返回值类型为void，则子类重写发方法返回值类型也必须为void</li><li>父类被重写发方法返回值类型为A，则子类重写的方法返回值类型可以是A类，或者A的子类</li><li>父类被重写的方法的返回值类型是基本数据类型（double），则子类重写的方法的返回值类型必须是相同的基本数据类型（也是double）</li></ol></li><li><p>子类重写的方法抛出的异常类型不大于父类被重写发方法抛出的异常类型</p></li></ol></li><li><p> <font style="background: #ffff55">子类和父类中发同名参数的方法要么都声明为非static的(可以考虑重写)，要么都声明为static(不可以重写)</p></li><li><p><font style="background: #ffff55">构造器是不可以被重写的</font></p><blockquote><p>总结：override和重载(Overloading)不同之处：</p><ol><li>重载只可以在用一个类中实现，而override只可以在子父类中实现</li><li>重载的方法名必须相同，而override不仅方法名必须相同且返回值类型也必须相同</li><li>重载的参数列表不同，而override的参数列表必须相同</li></ol></blockquote><h2 id="六、super关键字"><a href="#六、super关键字" class="headerlink" title="六、super关键字"></a>六、super关键字</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3></li></ol><ul><li>super理解为：父类</li><li>可以调用：属性、方法、构造器</li></ul><h3 id="super调用属性和方法"><a href="#super调用属性和方法" class="headerlink" title="super调用属性和方法"></a>super调用属性和方法</h3><ol><li>可以在子类的方法或构造器中，通过使用”super.属性”或”super.方法名()”的方式，显示的调用父类中声明的属性或方法。但是，通常情况下我们省略’super’关键字</li><li><font color=red>当父类和子类中定义了同名的属性时</font>，我们想要子类中调用父类中声明的属性，<font style="background: #ffff55">则必须使用”super.属性”的方式，表示调用的是父类中声明的属性</font></li><li><font color=red>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时</font>，则<font style="background: #ffff55">必须使用”super.方法()”方法，表示调用的是父类中声明的方法</font></li></ol><h3 id="super调用构造器"><a href="#super调用构造器" class="headerlink" title="super调用构造器"></a>super调用构造器</h3><ol><li>可以在子类的构造器中显示的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li><li>“super(形参列表)”的使用，必须声明在子类构造器的首行！！</li><li><font style="background: #ffff55">在类的构造器中，针对与“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现</font></li><li>在构造器的首行，没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参构造器“super()”</li></ol><h2 id="七、单元测试的方法-了解、但经常会用到"><a href="#七、单元测试的方法-了解、但经常会用到" class="headerlink" title="七、单元测试的方法(了解、但经常会用到)"></a>七、单元测试的方法(了解、但经常会用到)</h2><p><strong>实现步骤(6步)</strong></p><ul><li><pre><code>选中当前工程-右键选择：bulid path - add libraries - Junit 4 - 下一步</code></pre></li><li><p>创建java类，进行单元测试</p><ul><li><font style="background: #ffff55">此时的java类的要求：①此类是public的 ②此类提供公共的无参构造器</font></li></ul></li><li><p>此类中声明单元测试的方法：</p><ul><li><font style="background: #ffff55">此时的单元测试的方法：方法的权限为public，没有返回值（也就是void类型），没有形参</font></li></ul></li><li><p><font style="background: #ffff55">此时单元测试方法上需要声明注解：@Test,并在单元测试类中导入import org.junit.jupiter.api.Test; </font></p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p></li><li><p>写完代码后，左键双击单元测试的方法名。</p></li><li><p>只能用于方法上面，不能用于类</p></li><li><p>说明：</p><ul><li> 如果执行成功没有异常：绿色；失败:红色</li></ul></li></ul><h2 id="八、包装类"><a href="#八、包装类" class="headerlink" title="八、包装类"></a>八、包装类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</li><li>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 </li><li><img src="../imgs/%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt="包装类的图片"></li></ol><h3 id="数据类型、包装类、String三者相互转换"><a href="#数据类型、包装类、String三者相互转换" class="headerlink" title="数据类型、包装类、String三者相互转换"></a>数据类型、包装类、String三者相互转换</h3><blockquote><p>前提介绍：</p><ol><li>基本数据类型包装成包装类的实例 通过包装类的构造器实现： 还可以通过字符串参数构造包装类对象。</li><li>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。意思就是：</li></ol><ul><li>包装类—–&gt;基本数据类型：不需要使用xxxValue();</li><li>基本数据类型—&gt;包装成包装类 不需要通过包装类的构造器实现。看方法：test1();</li><li>类型必须匹配.所以可以把基本数据类型和包装类看成一个整体，然后与字符串相互转换。</li></ul><ol start="3"><li>所以，我们这里就不在整理jdk1.5之前转换方法的方法了。</li></ol></blockquote><pre class=" language-Java"><code class="language-Java">//数据类型、包装类之间的转换@Test    //自动装箱，自动拆箱    public void test1() &#123;        //自动装箱：数据类型 ---->包装类        int num=10;        Integer i=num;        System.out.println(i.toString()+2);                //自动拆箱：包装类 ---->数据类型        int b=i;        System.out.println(b+2);            &#125;//(数据类型、包装类) 和String之间的相互转换    @Test    //基本数据类型、包装类---->字符串类型String,使用String方法中重载的valueof()。    public void test3() &#123;        int i=10;        Integer b=20;        String str=String.valueOf(i);        String str2=String.valueOf(b);               //控制台中出现不了""        System.out.println(str.toString()+1);        System.out.println(str2+1);    &#125;   @Test    //字符串类型String---->基本数据类型、包装类.使用包装类中的parseXxx()方法。方便记忆：这里面的'的'就可以看做为'.'    public void test4() &#123;        String str1="123";        int parseInt = Integer.parseInt(str1);        System.out.println(parseInt+1);    &#125;</code></pre><h2 id="九、static、final关键字"><a href="#九、static、final关键字" class="headerlink" title="九、static、final关键字"></a>九、static、final关键字</h2><h3 id="static介绍"><a href="#static介绍" class="headerlink" title="static介绍"></a>static介绍</h3><ol><li>意思：静态的</li><li>可以用来修饰类的部分成员：属性、方法、代码块、内部类</li><li>修改属性：静态变量(类变量)所有对象都共享了这个静态变量<ol><li>属性：按是否使用static分为静态变量(类变量)和非静态变量(实例变量)</li><li>实例变量：创建了类的多个对象，每个对象都独立拥有一套类中的非静态变量。当修改其中对象的非静态变量之后，不会导致其他对象的相同属性值改变</li><li>静态变量：创建了类的多个对象，多个对象共享同一个静态变量，当通过某个对象修改静态变量之后，会导致其他对象调用静态变量之后，是修改过的</li><li>修改属性的其他说明：<ol><li>随着类的加载而加载，可以通过”类.静态变量（类变量）”的方式调用，不需要创建对象就可以调用类方法。</li><li>优先于对象存在</li><li>修饰的成员，被所有对象所共享</li><li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ol></li><li>图解：<br><img src="../imgs/static%E5%9B%BE.png" alt="static运用图"></li></ol></li><li>static修饰方法<ol><li>随着类的加载而加载 ，可以通过”类.静态方法()”的方式调用，不需要创建对象就可以调用类方法.</li><li><table>   <caption style="background:#ccc">是否可以调用</caption>   <tr>      <td></td>      <td>静态对象</td>      <td>非静态对象</td>   </tr>   <tr>      <td>类</td>      <td>YES</td>      <td>NO</td>   </tr>   <tr>      <td>对象</td>      <td>YES</td>      <td>YES</td>   </tr></table></li><li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li><li>非静态方法中，即可以调用非静态的属性和方法，也可以调用静态中的方法和属性</li></ol></li></ol><blockquote><p>注意点：</p><ul><li>static方法内部不能有this(this指的是当前对象的调用，static方法根本就不需要创建对象)。也不能有super</li><li>static修饰的方法不能被重写</li><li>关于静态属性和方法，我们应该从生命周期角度理解。父–子–儿（角度）</li></ul><ol start="5"><li>开发中，如何确定一个属性是否要声明static类型？</li></ol></blockquote><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同</li></ul><ol start="6"><li>开发中，如何确定一个方法是否要声明static类型？<ul><li>操作静态属性的方法，通常设置为static类型<br>Java中工具类的方法，习惯上声明为static的。比如：Math、Arrays等</li></ul></li></ol><h3 id="final介绍"><a href="#final介绍" class="headerlink" title="final介绍"></a>final介绍</h3><ol><li><p>意思为：最终的，言简意赅，就知道final修饰的任何的东西，都是最后的结果。</p></li><li><p>可以修饰：类、方法、变量</p></li><li><p>修饰类：</p><ol><li>此类不能被其他类所继承了，可以理解为此类是最终类</li><li>比如：String类、System类、StringBuffer类等</li></ol></li><li><p>修饰方法：</p><ol><li>表明此方法不可以重写</li><li>比如：Object类中的getClass();</li></ol></li><li><p>修饰变量</p><ol><li>此时“变量”就会变为一个常量</li><li>修饰属性<ol><li> 可以赋值的位置有：显示初始化、代码块中初始化、构造器中初始化</li></ol></li><li>修饰局部变量<ol><li>法中的局部变量</li><li>形参</li></ol></li></ol></li></ol><blockquote><p>注意：<br>&ensp;尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法，给“常量形参”赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不可以进行重新赋值.</p><ul><li>static final ：用来修饰属性：全局常量</li></ul></blockquote><h2 id="十、抽象类与抽象方法、接口-interface"><a href="#十、抽象类与抽象方法、接口-interface" class="headerlink" title="十、抽象类与抽象方法、接口(interface)"></a>十、抽象类与抽象方法、接口(interface)</h2><h3 id="抽象类、抽象方法"><a href="#抽象类、抽象方法" class="headerlink" title="抽象类、抽象方法"></a>抽象类、抽象方法</h3><ol><li><p>abstract的介绍</p><ol><li><p>意思为：抽象</p></li><li><p>可以修饰：方法、类</p></li><li><p>修饰类：(抽象类)</p><ol><li>此类不可以创建实例化，也就是不能new一个新的对象</li><li>抽象类中一定有构造器，便于子类实例化时调用(涉及：子类对象实例化的全过程)</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，然后完成相关操作</li></ol></li><li><p>修饰方法：(抽象方法)</p><ol><li>抽象方法只有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是抽象类，反之不然，抽象类中可以没有抽象方法</li><li>如子类重写了父类中的所有抽象方法后，此子类就可以实例化，不会报错。如果子类没有重写父类中的所有抽象方法，则子类也是一个抽象类，否则报错<blockquote><p>总结：<br><code>抽象使用的前提：</code></p><ol><li>使用面向对象三个属性中的多态性</li><li>继承性</li></ol><ul><li>abstract基本上都是<code>基于重写</code>方法来实现的</li><li>abstract不能修饰：属性、构造器、代码块等结构</li><li>abstract不能用来修饰私有的方法、静态方法（因为不能被重写）、final类、final方法</li></ul></blockquote></li></ol></li></ol></li></ol><p>相关问题：</p><ul><li>为什么抽象类不可以使用final关键字声明？<ul><li>final修饰的类不能被继承，所有不能有子类。然而抽象类只能被子类所继承，两者相冲突。所以abstract类不能被final修饰。</li></ul></li><li>一个抽象类中可以定义构造器吗？ <ul><li>可以，子类实例化之后，被子类所调用。使用super关键字调用</li></ul></li><li>是否可以这样理解：抽象类就是比普通类多定义了抽象方 法，除了不能直接进行类的实例化操作之外，并没有任何的不同？ <ul><li>可以</li></ul></li></ul><h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h3><ol><li><p>在java中接口使用interface来定义，使用implements去实现接口</p></li><li><p>接口和类是并列的两个结构，且接口是特殊的抽象类，所以抽象类实现接口，不用重写接口中的抽象方法</p></li><li><p>如何定义接口?</p><ol><li>JDK7及之前：<ol><li>全局变量：都默认是由public static final修饰的</li><li>抽象方法都默认是由public abstract修饰的</li></ol></li><li>JDK8：除了定义全局变量和抽象方法之外，还可以定义静态方法、默认方法（default）<ol><li>知识点1：接口中定义的静态方法，只能通过接口来调用</li><li>知识点2：通过实现类的对象，可以调用接口中默认的方法<ol><li>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写之后的方法</li></ol></li><li>知识点3：如果子类（实现类）继承父类和实现接口中声明了同名同参的默认方法，那么子类在没有重写的情况下，默认调用的是父类中同名同参数的方法 —–&gt;类优先原则</li><li>知识点4：如果实现类实现多个接口，而多个接口中有同名同参数的默认方法，那么实现类在没有重写的情况下，报错。—&gt;接口冲突。<ol><li>解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</li></ol></li><li>知识点5：如何在实现类的方法中调用接口中被重写的方法—默认的方法<ol><li>接口名.super.方法名();</li></ol></li><li>接口中没有构造器，意味着接口就不可以创建实例（创建对象）</li><li>接口采用多继承机制。</li></ol></li></ol></li><li><p>java开发中，接口通过 让 类 去 实现(implement) 的 方式 来使用</p><ol><li>如果实现类覆盖了接口中的抽象方法，则此实现类就可以实例化</li><li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类是抽象类</li></ol></li><li><p>java类可以实现多个接口 ——&gt;弥补了java单继承性的局限性</p><ul><li>格式：class SubClass extends SuperClass implements AA,BB,CC,….{ }</li></ul></li><li><p>类与类之间实现继承、类与接口之间使用 实现 implements 。接口和接口也使用继承，不过和类之间不一样，可以多继承。（这是因为接口不可以实例化）</p></li></ol><blockquote><p>总结：接口与抽象类之间的区别</p><table>    <tr>       <td>NO.</td>       <td>区别点</td>       <td>抽象类</td>       <td>接口</td>    </tr>    <tr>       <td>1</td>       <td>定义</td>       <td>包含抽象方法的类</td>       <td>主要是抽象方法和全局常量的集合</td>    </tr><tr>       <td>2</td>       <td>组成</td>       <td>构造方法、抽象方法、普通方法、常量、变量</td>       <td>常量、抽象方法、(JDK8：默认方法、静态方法)</td>    </tr><tr>       <td>3</td>       <td>使用</td>       <td>子类继承抽象类</td>       <td>子类实现接口</td>    </tr><tr>       <td>4</td>       <td>关系</td>       <td>抽象类可以实现多个接口</td>       <td>接口不能继承抽象类，但允许继承多个接口</td>    </tr><tr>       <td>5</td>       <td>对象</td>       <td>都是通过对象的多态性产生实例话的对象</td>       <td>都是通过对象的多态性产生实例话的对象</td>    </tr></table></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> BASIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现十大排序算法</title>
      <link href="/2022/102638641.html"/>
      <url>/2022/102638641.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大经典排序"><a href="#十大经典排序" class="headerlink" title="十大经典排序"></a>十大经典排序</h1><p>&ensp;本学期学了数据结构,为了更好的去理解其中的知识,同时也为了训练自己的相关思想，总而言之，既然花时间去做了这件事，就得有所成果。所以，为了让自己理解的更加透彻，我想把自己所学、所理解的的内容，在此分享给友友们。如果有地方不理解或者有错误，大家可以在本篇文章底部进行评论、私聊我可以。我看到会及时回复大家的。那么好，我们言归正传，下面正式介绍十大算法，因为时间问题，我会分成两篇文章进行介绍。</p><h2 id="一、排序的说明"><a href="#一、排序的说明" class="headerlink" title="一、排序的说明"></a>一、排序的说明</h2><h3 id="1-1-排序的定义"><a href="#1-1-排序的定义" class="headerlink" title="1.1 排序的定义"></a>1.1 排序的定义</h3><p>对一序列对象根据某个关键字进行排序</p><h3 id="1-2-术语说明"><a href="#1-2-术语说明" class="headerlink" title="1.2 术语说明"></a>1.2 术语说明</h3><ul><li>稳定：如果a原本排序在b的前面，而a=b，排序之后a任然在b的前面;</li><li>不稳定：如果如果a原本排序在b的前面，而a=b，排序之后a却在b的后面;</li><li>内排序：所有排序操作都在内存中完成</li><li>外排序：由于数据量太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;</li><li>时间复杂度：一个算法执行所耗费的时间</li><li>空间复杂度：运行完一个程序所需内存的大小<h3 id="1-3-算法的总结"><a href="#1-3-算法的总结" class="headerlink" title="1.3 算法的总结"></a>1.3 算法的总结</h3></li><li><img src="../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="图片理解"></li><li>名词解释：<ul><li>n:数据规模<ul><li> <font style="background:#ff22">解释：运行一个O(n)的程序，观察n对程序运行时间的影响。</font></li></ul></li><li>k:‘桶’的个数<ul><li> ‘桶’的基本了解：它所统计的就是每个数据在数据集合中一共出现了多少次。</li><li> <font style="background:#ff22">这里引用了大佬的比喻：一般的数据结构，就好比有几个篮子(A,B,C)，我们接到了一个新的数据，就要考虑将其按我们想要的那种方式分类，然后扔到某一个篮子里。桶呢？就好比有几个篮子(1,2,3,4)，我们接到了一个新的数据，只看这个数据到底是什么，是1就扔进1号篮，2就扔进2号篮，以此类推。</font></li></ul></li><li> In-place:占用内存，不占用额外的内存</li><li> Out-place:占用额外的内存</li></ul></li></ul><h3 id="1-4-比较和非比较的区别"><a href="#1-4-比较和非比较的区别" class="headerlink" title="1.4 比较和非比较的区别"></a>1.4 比较和非比较的区别</h3><p>&ensp;常见的<em><strong>快速排序、归并排序、堆排序、冒泡排序等</strong></em>属于<font color=red>比较排序</font>。<strong>在排序的最终结果中，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong><br>&ensp;在冒泡排序之类的排序中，问题规模为n，又因为需要比较n此，所以平均时间复杂度为O(n^2)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>&ensp;计数排序、基数排序、桶排序属于非比较排序。<em><strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr,计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置</strong></em>。<br>&ensp;非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p><blockquote><p>总结：<br>&ensp;比较排序的优势是，使用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。<br>&ensp;非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定的要求。</p></blockquote><h2 id="二、十大经典排序一：冒泡排序-Bubble-Sort"><a href="#二、十大经典排序一：冒泡排序-Bubble-Sort" class="headerlink" title="二、十大经典排序一：冒泡排序(Bubble Sort)"></a>二、十大经典排序一：冒泡排序(Bubble Sort)</h2><h3 id="2-1-说明："><a href="#2-1-说明：" class="headerlink" title="2.1 说明："></a>2.1 说明：</h3><p>&ensp;冒泡排序是一种简单的排序算法。它重复走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换。走访数列的工作是重复的进行直到没有在需要交换。此时该数列已经排序完成。</p><h3 id="2-2-算法描述-以升序为例"><a href="#2-2-算法描述-以升序为例" class="headerlink" title="2.2 算法描述(以升序为例)"></a>2.2 算法描述(以升序为例)</h3><ul><li>比较相邻的两个元素。如果第一个比第二个大，就交换它们两。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素会是数组中最大的数。</li><li><font style="background:#abab">针对所有元素重复以上的步骤，此时，除去最后一个</font></li><li>重复上面3步操作，知道排序完成。<h3 id="2-3-动图显示"><a href="#2-3-动图显示" class="headerlink" title="2.3 动图显示"></a>2.3 动图显示</h3><img src="../imgs/%E5%8A%A8%E6%80%81.gif" alt="冒泡排序"><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><pre class=" language-Java"><code class="language-Java">public int[] Bubble(int[] arry)&#123;  //先判断数组中是否有数据      if(arr.length == 0)&#123;              return arr;          &#125;  //这里的i表示比较的趟数       for (int i = 0; i < arry.length; i++) &#123;          //j表示数组下标，因为每次完成一次趟数下一趟就会少一个数进行比较          for (int j = 0; j < arry.length-i-1; j++) &#123;              if(arry[j]>arry[j+1])&#123;                  //temp为临时变量，两个数据之间的交换操作                  int temp=arry[j];                  arry[j]=arry[j+1];                  arry[j+1]=temp;              &#125;          &#125;      &#125;      return arry;  &#125;</code></pre><h3 id="2-5-算法分析"><a href="#2-5-算法分析" class="headerlink" title="2.5 算法分析"></a>2.5 算法分析</h3></li><li>最佳情况：T(n)=O(n)—-&gt;表示一次就成功</li><li>最差情况：T(n)=O(n^2) —–&gt;表示最后才成功</li><li>平均情况：T(n)=O(n^2)</li></ul><h2 id="三、十大经典排序二：选择排序-Selection-Sort"><a href="#三、十大经典排序二：选择排序-Selection-Sort" class="headerlink" title="三、十大经典排序二：选择排序(Selection Sort)"></a>三、十大经典排序二：选择排序(Selection Sort)</h2><h3 id="3-1-说明："><a href="#3-1-说明：" class="headerlink" title="3.1 说明："></a>3.1 说明：</h3><p>&ensp;表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，<font style="background:orange">所以用到它的时候，<strong>数据规模越小越好</strong>。唯一的好处可能就是不占用额外的内存空间。</font><br>&ensp;工作原理：首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。依次类推，直接所有元素均排序完毕。</p><h3 id="3-2-算法描述"><a href="#3-2-算法描述" class="headerlink" title="3.2 算法描述"></a>3.2 算法描述</h3><p>&ensp;n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体描述如下：</p><ul><li>初始状态：无序区[1….n],有序区为空;</li><li>第i(i∈(1,2,3..))趟排序开始时,当前有序区和无序区分别为R[1….i-1]和R[i…n)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第i个记录R交换，使R[1….i-1]和R[i…n)分别变为记录个数增加1个新有序区和记录个数减少1个的新无序区。<h3 id="3-3-动画演示"><a href="#3-3-动画演示" class="headerlink" title="3.3 动画演示"></a>3.3 动画演示</h3><img src="../imgs/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"><h3 id="3-4-代码排序"><a href="#3-4-代码排序" class="headerlink" title="3.4 代码排序"></a>3.4 代码排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">Selection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//先判断数组中是否有数据</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> arr<span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//假设，下标为i所对应的值为最小</span>          <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//把最小值的小标赋给minIndex</span>                  minIndex<span class="token operator">=</span>j<span class="token punctuation">;</span>              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//根据下标的对应值进行交换数据</span>          <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//如果下标i后面没有比它小的值，则位置不变，i++</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="3-5-算法分析"><a href="#3-5-算法分析" class="headerlink" title="3.5 算法分析"></a>3.5 算法分析</h3></li><li>最佳情况：T(n)=O(n^2)</li><li>最差情况：T(n)=O(n^2)</li><li>平均情况：T(n)=O(n^2)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础二</title>
      <link href="/2022/102562568.html"/>
      <url>/2022/102562568.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础二"><a href="#Java基础二" class="headerlink" title="Java基础二"></a>Java基础二</h1><h2 id="一、方法重载"><a href="#一、方法重载" class="headerlink" title="一、方法重载"></a>一、方法重载</h2><p><font color=red>定义：</font><br>&emsp;同一个类中，允许存在一个以上同一个方法名的方法，只要他们的<font color=blue>参数个数或参数类型不同</font>就可以。  </p><blockquote><p>总结：方法重载判断(两同一不同)：(类相同、方法名相同、参数(类型、个数)不同)。<br>判断是否是重载：与方法的权限修饰、返回值类型、形参变量名、方法体都没有关系。</p></blockquote><h2 id="二、匿名对象"><a href="#二、匿名对象" class="headerlink" title="二、匿名对象"></a>二、匿名对象</h2><p>理解：  </p><ul><li>创建对象没有显示的赋给一个变量名。即匿名对象。例如：new People();</li><li>调用类中的属性或方法：new People().属性、new People().方法();  </li></ul><p>特征：匿名对象只能调用一次。因为new一个就代表一个对象。  </p><h2 id="三、方法形参的传递机制：值传递"><a href="#三、方法形参的传递机制：值传递" class="headerlink" title="三、方法形参的传递机制：值传递"></a>三、方法形参的传递机制：值传递</h2><p> 1.<font color=red>形参</font>：方法定义时，声明的小括号中的值<br> 2.<font color=red>实参</font>：对象调用时候，实参传递给形参的值为实参</p><h3 id="值传递机制"><a href="#值传递机制" class="headerlink" title="值传递机制"></a>值传递机制</h3><p>1.如果变量为基本数据类型，此时赋值的是变量所保存的数据值<br>2.如果变量是引用数据类型==对象调用，此时赋值的变量所保存的数据的地址值。<br>3.<font style="background: orange">如果参数为基本数据类型，此时实参赋给形参的是实参真实存储的数据值</font><br>4.<font style="background: orange">如果参数是引用数据类型==对象调用，此时赋值的变量所保存的数据的地址值  </font></p><h2 id="四、Recursion-递归-了解"><a href="#四、Recursion-递归-了解" class="headerlink" title="四、Recursion(递归)了解"></a>四、Recursion(递归)了解</h2><ul><li>  递归方法：一个方法体内调用它自身。</li><li>  方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li><li>  递归一定要向已知方向递归，否则这种递归就变成了无穷递归，就是死循环。</li><li>  递归对程序不是一无是处的，相反，递归对训练自己的思维很有帮助</li></ul><h2 id="五、面向对象之一：封装-potting与隐藏"><a href="#五、面向对象之一：封装-potting与隐藏" class="headerlink" title="五、面向对象之一：封装 potting与隐藏"></a>五、面向对象之一：封装 potting与隐藏</h2><p>1.该隐藏的隐藏，该暴露的暴露。这是<font style="background: #5246">封装性的思想</font>  </p><ul><li> <font style="background: #3333">问题引入：<blockquote><p>&ensp;当创建一个类的对象之后，可以通过“对象.属性”方式，对对象的属性进行赋值。这时候，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他限制条件。<br>&ensp;但是在实际生活中，我们需要给属性赋值加入额外的限制条件。这个条件就不能再属性声明时体现。我们只能通过方法进行限制条件的添加。同时，需要避免用户再使用“对象.属性”方式进行赋值。则需要将属性声明为私有的（private）。—&gt;此时，针对于属性就体现了封装性  </p></blockquote></li><li>封装性的体现：<ul><li><font color=red>将类的属性（xxx）私有化（private),同时，提供共有的方法来获取（getXxx）和设置(setXxx)</font></li></ul></li><li>封装性的体现，需要权限修饰符来配合<ul><li>Java中规定4中权限（有小到大）：<font style="background: orange">private、缺省（default）就是省略、protected、public</font></li><li><img src="../imgs/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0.png" alt="权限修饰图范围"></li></ul></li></ul><blockquote><p>总结：<br>1、总结封装性：Java提供了4中权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小<br>2.不建议把set和get的功能写在同一个方法中，因为会发生明知故问这样情况。<br>3、(tips:)eclipse中快捷键设置set和get方法：Alt+Shift+s</p></blockquote><h2 id="六、面向对象之二：继承性"><a href="#六、面向对象之二：继承性" class="headerlink" title="六、面向对象之二：继承性"></a>六、面向对象之二：继承性</h2><p>1.为什么要有继承？  WHY ? What  :  how  </p><ul><li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。 </li><li>Eg:Student类继承了父类Person的所有属性和方法，并增加了一 个属性school。Person中的属性和方法,Student都可以使用。  </li></ul><p>2.继承的好处：</p><ul><li>继承的出现减少了代码冗余，提高了代码的复用性。   </li><li>继承的出现，更有利于功能的扩展。 </li><li>继承的出现让类与类之间产生了关系，提供了多态的前提。<blockquote><p><font style="background:#ffff00">注意：不要仅为了获取其他类中某个功能而去继承，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。</font></p></blockquote></li></ul><p>3.类继承语法规则：</p><ul><li><p>class Student extends Person{}</p><ul><li>Student 为 子类、派生类、subclass</li><li>Person：父类、基类 、超类、superclass</li></ul></li><li><p>体现：</p><ul><li>一旦A类继承B类以后，子类A就获取了父类B中声明的所有属性和方法<br><font style="background:#ffff00">特别的，父类中声明为private的属性或方法，子类继承父类之后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</font></li><li>子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的扩展。<font style="background:#ffff00">子类功能 &gt; 父类功能</font></li></ul></li></ul><p>4.继承性的规定：</p><ul><li><font color="background:#ffff00">Java只支持单继承和多层继承，不允许多重继承</li><li>一个子类只能有一个父类 ：单继承</li><li>一个父类可以派生出多个子类 ：</li><li>子类直接继承父类，称为：直接父类。C→A为：间接父类</li><li>C可以继承所有B和A类的所有方法和属性</font></li></ul><p>5.间接父类图形演示：<br>&emsp;&emsp;&emsp;&emsp;&emsp;<img src="../imgs/%E7%AE%80%E4%BB%8B%E7%88%B6%E7%B1%BB.png" alt="间接父类"></p><h2 id="七、面向对象之三：多态性"><a href="#七、面向对象之三：多态性" class="headerlink" title="七、面向对象之三：多态性"></a>七、面向对象之三：多态性</h2><p>1.理解多态性：<br>可以理解为一个事物的多种形态。就是引用父类的类型调用子类重写父类的方法。  </p><p>2.何为多态：  </p><ul><li>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）。</li><li>Eg:<ul><li>Person p1=new Man();p1（引用）为person类型，子类的对象：new Man()（new了一个对象）</li></ul></li></ul><p>3.多态性的使用：虚拟方法调用</p><ul><li><p>虚拟方法调用：</p><ul><li>子类中定义了与父类同名同参数的方法（重写），在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法 确定的。 </li></ul></li><li><p>有了对象多态以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们实际执行的是子类重写父类的方法。</p><blockquote><p>总结：<strong>编译看左边；运行结果看右边；</strong> </p></blockquote></li></ul><p>4.多态性：<font color="background:#ffff00">只适用于方法，不适用于属性(编译和运行都看左边类的类型)</font></p><p>5.<font color="background:#ffff00">多态性的使用前提：（方法）</font></p><ul><li><font color=red>类的继承关系(子父类关系)</li><li>方法的重写(override)</font></li><li>不能调用子类所特有的方法；编译时，引用是父类的类型，所以必须是重写的方法</li></ul><p>6.多态的使用：<br>&emsp;当调用子父类同名同参数的方法时，实际执行的是子类的重写的方法。  </p><blockquote><p>总结：子类继承父类</p><ul><li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的 同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边，运行在右边.</li><li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的 实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量（因为多态不适用于属性。）所以当子类和父类中有相同的属性名，则引用谁就调用谁的方法。编译运行都看左边</li></ul></blockquote><p>7.instanceof 操作符</p><ul><li>x instanceof A：检验x是否为类A的对象，返回值为boolean型。 </li><li>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 </li><li>如果x属于类A的子类B，x instanceof A值也为true。 </li></ul><p>8.图片理解<br><img src="../imgs/instanceof.png" alt="instanceof"><br>9.向下转型：</p><ul><li>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致了编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。</li><li>如何才能调用子类特有的属性和方法？<ul><li>向下转型：使用强制类型转换符  </li></ul></li></ul><p>10.向上转型（多态）：子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象。</p><h2 id="八、类的成员之三：构造器-构造方法"><a href="#八、类的成员之三：构造器-构造方法" class="headerlink" title="八、类的成员之三：构造器(构造方法)"></a>八、类的成员之三：构造器(构造方法)</h2><h3 id="1、构造器特征以及作用"><a href="#1、构造器特征以及作用" class="headerlink" title="1、构造器特征以及作用"></a>1、构造器特征以及作用</h3><p>1.具有与类相同的名称<br>2.不声明返回值类型。(与声明void不同)<br>3.不能被static、final、synchronized、abstract、native修饰，不能有<br>return语句返回值<br>4.创建对象、给对象进行初始化<br>5.语法格式</p><ul><li>修饰符 类型(参数列表){初始化语句;}</li></ul><h3 id="2、构造器的分类"><a href="#2、构造器的分类" class="headerlink" title="2、构造器的分类"></a>2、构造器的分类</h3><p>1.根据参数不同，构造器可以分为如下两类：</p><ul><li>隐式无参构造器（系统默认提供）</li><li>显式定义一个或多个构造器（无参、有参）</li></ul><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><ul><li>Java语言中，每个类都至少有一个构造器</li><li>默认构造器的修饰符与所属类的修饰符一致</li><li>一旦显式定义了构造器，则系统不再提供默认构造器</li><li>一个类可以创建多个重载的构造器</li><li>父类的构造器不可被子类继承</li></ul><h3 id="4、属性赋值的过程"><a href="#4、属性赋值的过程" class="headerlink" title="4、属性赋值的过程"></a>4、属性赋值的过程</h3><ul><li>赋值的位置：<br>a、默认初始化<br>b、显示初始化<br>c、 构造器中初始化<br>d、 通过”对象.属性”或”对象.方法()”的方式赋值</li><li>赋值的先后顺序<br>a-b-c-d</li></ul><h2 id="九、关键字–this、import、package"><a href="#九、关键字–this、import、package" class="headerlink" title="九、关键字–this、import、package"></a>九、关键字–this、import、package</h2><h3 id="1、this是什么？"><a href="#1、this是什么？" class="headerlink" title="1、this是什么？"></a>1、this是什么？</h3><p>1.<font color=red>它在方法内部使用，即这个方法所属对象的引用；<br>2.它在构造器内部使用，表示该构造器正在初始化的对象。</font></p><h3 id="2、this的作用"><a href="#2、this的作用" class="headerlink" title="2、this的作用"></a>2、this的作用</h3><ul><li>this 可以调用类的属性、方法和构造器</li><li><strong>什么时候使用this关键字呢？</strong><ul><li>当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。</li></ul></li><li><em><strong>下面的段落非常重要，大概率可以帮助你理解this关键字的用法。</strong></em><blockquote><ol><li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this.</li><li><font color="#ff22f">当形参与成员变量同名时，<font style="background:orange">如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</font>。使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。</font> </li><li>this可以作为一个类中构造器相互调用的特殊格式</li></ol></blockquote></li></ul><h3 id="3、this的使用要求："><a href="#3、this的使用要求：" class="headerlink" title="3、this的使用要求："></a>3、this的使用要求：</h3><ol><li>构造器中不能通过”this(形参列表)”的方式调用自身构造器</li><li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了<br>“this(形参列表)”  </li><li>“this(形参列表)”必须声明在类的构造器的首行！</li><li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li></ol><h3 id="4、Package关键字的使用"><a href="#4、Package关键字的使用" class="headerlink" title="4、Package关键字的使用"></a>4、Package关键字的使用</h3><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包属于标识符，遵循标识符的命名规则、规范、“见名知意”</li><li>package命名时候每一个“.”代表一层文件目录<ol><li>补充：<ol><li>同一个包中，不能命名同名的接口、类</li><li>不同包下，可以命名同名的接口、类</li></ol></li></ol></li></ol><h3 id="5、import关键字的使用"><a href="#5、import关键字的使用" class="headerlink" title="5、import关键字的使用"></a>5、import关键字的使用</h3><ol><li>import：导入</li><li>在源文件中显示使用import结构导入指定包下的类、接口</li><li>如果使用的类或接口在本包下面定义的，则可以省略使用import</li><li>如果在源文件中，使用了不同包下的同名类，则必须至少有一个类需要以全名类（包的名字.类的名字）的方式显示</li><li>Import static：导入指定类或接口中的静态方法结构：属性或方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> BASIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础一</title>
      <link href="/2022/102437225.html"/>
      <url>/2022/102437225.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的基本数据类型-两类、8个"><a href="#Java中的基本数据类型-两类、8个" class="headerlink" title="Java中的基本数据类型(两类、8个)"></a>Java中的基本数据类型(两类、8个)</h1><h2 id="数值类型-–-gt-六个"><a href="#数值类型-–-gt-六个" class="headerlink" title="数值类型 –&gt;六个"></a>数值类型 –&gt;六个</h2><p>整型：<br>1.byte(字节型)：内存占1个字节<br>2.short(短整型)：内存占2个字节<br>3.int(整型)：内存占4个字节<br>4.long(长整型)：内存占8个字节<br>浮点型：<br>1.float(单精度浮点型)：内存中占4个字节<br>2.double(双精度浮点型)：内存中占8个字节</p><h2 id="非数值类型-–-gt-两个"><a href="#非数值类型-–-gt-两个" class="headerlink" title="非数值类型 –&gt;两个"></a>非数值类型 –&gt;两个</h2><p>1.char(字符串)：内存中占2个字节<br>2.boolean(布尔型)：boolean类型被编译成int类型来使用时，占4个byte。boolean数组被编译成byte数组，每个boolean数组成员占1个byte(8位)。在Java虚拟机里，00000001表示true，00000000表示false。</p><blockquote><p>注意c语言中的char占用1个字节。<br>提示：int（数值基本类型）类型默认值为：0；boolean类型默认为：false；String默认值为：null；因为String为类，不是基本数据类型（切记）—(具体原因，后期更新!)</p></blockquote><h2 id="一维数组的声明"><a href="#一维数组的声明" class="headerlink" title="一维数组的声明"></a>一维数组的声明</h2><ul><li>int[] 数组名=null；</li><li>int 数组名[]=null；</li><li>int[] 数组名=new int[3]；</li></ul><h2 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h2><ul><li>float[][] numthree; </li><li>numthree=new float[5][5]; </li><li>short[][] numfour=new short[5][8]</li><li>short[][] numfour=new short[5][]</li></ul><h1 id="OOP的三条主线"><a href="#OOP的三条主线" class="headerlink" title="OOP的三条主线"></a>OOP的三条主线</h1><h2 id="一、类及类的成员"><a href="#一、类及类的成员" class="headerlink" title="一、类及类的成员"></a>一、类及类的成员</h2><p>  1.属性：成员变量=field=字段、域<br>  2.方法：函数=成员方法=method<br>  3.构造器<br>  4.内部类<br>  5.代码块</p><h3 id="类和对象的理解，两者之间的关系"><a href="#类和对象的理解，两者之间的关系" class="headerlink" title="类和对象的理解，两者之间的关系"></a>类和对象的理解，两者之间的关系</h3><blockquote><p>类：抽象的、概念上的内容。对象：实实在在存在的一个个体。对象是由类new出来的，每new一个都是一个新的对象。</p></blockquote><h3 id="驼峰式命名"><a href="#驼峰式命名" class="headerlink" title="驼峰式命名"></a>驼峰式命名</h3><blockquote><p>类名的命名、接口名、命名空间等 —–&gt;大驼峰命名法的使用范围(首单词的首字母是否大写,若大写,则是大驼峰命名法)<br>变量名的命名、函数名(方法名)的命名等 —-&gt;小驼峰命名法(构成标识符的首单词的首字母小写,其他单词的首字母都大写)</p></blockquote><blockquote><p>鄙人刚部署好个人博客，四舍五入操作熟练度为0，编写文件内容格式很丑，目前不懂如何美化，并且第一次使用Markdown编辑器感觉很是鸡肋，没办法写出自己想要的效果。日后会寻找办法去改善这种情况。目前本人大三在读，日常分享Java基础知识。多多关注！多多分享！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> BASIC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
