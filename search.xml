<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础三</title>
      <link href="/2022/110638825.html"/>
      <url>/2022/110638825.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础三"><a href="#Java基础三" class="headerlink" title="Java基础三"></a>Java基础三</h1><h2 id="一、类的成员之四：代码块"><a href="#一、类的成员之四：代码块" class="headerlink" title="一、类的成员之四：代码块"></a>一、类的成员之四：代码块</h2><h3 id="认识代码块-Block"><a href="#认识代码块-Block" class="headerlink" title="认识代码块(Block)"></a>认识代码块(Block)</h3><ol><li><p>Block的作用：初始化类、对象</p></li><li><p>格式：在类中就是一个大括号{}或者static{},当然我们可以看做是一个方法</p></li><li><p>Block<font color=red>如果有修饰的话，只能使用static</font></p><h3 id="Block的分类"><a href="#Block的分类" class="headerlink" title="Block的分类"></a>Block的分类</h3></li><li><p>静态Block(static{})</p><ol><li>内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次，执行顺序总是第一个执行</li><li>作用：初始化类的信息</li><li>如果一个类中定义了多个静态代码块,则按出现的顺序执行</li></ol></li><li><p>非静态Block({})</p><ol><li> 内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次，执行顺序总是第一个执行</li><li>每创建一个对象，就执行一次非静态Block</li><li>如果一个类中定义了多个静态代码块,则按出现的顺序执行</li></ol></li></ol><blockquote><p>总结：对<font style="background: #ffff55">属性赋值的位置</font>优先顺序：</p><ol><li>默认初始化</li><li>显示初始化</li><li>构造器中初始化</li><li>对象实例化中”对象.属性”或者”对象.方法()”</li><li>使用代码块  </li></ol><p><font style="background: #ffff55">执行顺序：1 -&gt; 2/5 -&gt; 3 -&gt; 4;2/5顺序看哪一个写在前面</font></p></blockquote><h2 id="二、类的成员之五：内部类-了解"><a href="#二、类的成员之五：内部类-了解" class="headerlink" title="二、类的成员之五：内部类(了解)"></a>二、类的成员之五：内部类(了解)</h2><p>由于内部类不是常用的成员，所以大家就大致的了解一下就OK了</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;在Java中，允许一个类A的定义位于另一个类B的内部，A称为内部类，B称为外部类。 </p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>&emsp;成员内部类 （静态内部类、非静态内部类）vs 局部内部类（方法内、构造器内、代码块内);  </p><ol><li><p>成员内部类作为类的成员的角色：</p><ul><li>和外部类不同，Inner class还可以声明为private或protected；</li><li>可以调用外部类的结构</li><li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员<br>变量；  </li></ul></li><li><p>成员内部类作为类的角色：</p><ol><li>可以在内部定义属性、方法、构造器等结构</li><li>可以声明为abstract类 ，因此可以被其它的内部类继承</li><li>可以声明为final的</li><li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li></ol></li><li><p>注意：</p><ul><li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员 内部类中才可声明static成员。</li><li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 </li><li>成员内部类可以直接使用外部类的所有成员，包括私有的数据 ；当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态</li></ul></li></ol><h2 id="三、Object类的介绍"><a href="#三、Object类的介绍" class="headerlink" title="三、Object类的介绍"></a>三、Object类的介绍</h2><h3 id="Object的说明"><a href="#Object的说明" class="headerlink" title="Object的说明"></a>Object的说明</h3><ol><li>Object类是Java中所有类的根父类</li><li>如果我们没有声明一个类继承父类，则此类默认继承java.lang.Object类</li><li>所有的java类（除了java.lang.Object类之外）都直接或间接继承java.lang.Object类,意味着所有Java类都具有java.lang.Object类声明的功能</li><li><font style="background: #ffff55">Object只声明了一个空参构造器</font><h3 id="Object中部分方法"><a href="#Object中部分方法" class="headerlink" title="Object中部分方法"></a>Object中部分方法</h3></li><li>equals();</li><li>toString():<ol><li>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()。(如果自定义类不重写toString(),则输出地址值)</li><li>Object类中toString()的定义：<ol><li>public String toString(){return getClass.getName()+”@”+Integer.toHexString(hashCode())}; 获取虚拟地址值。所以需要重写该方法</li><li><font style="background: #ffff55">特别的：像String 、Date、File、包装类等都重写了Object类中的toString()方法。重写以后，使得在调用对象tostring()方法时，返回“实体内容”信息。</font></li></ol></li></ol></li></ol><h2 id="四、-和-equals-的区别-非常重要"><a href="#四、-和-equals-的区别-非常重要" class="headerlink" title="四、== 和 equals()的区别(非常重要)"></a>四、== 和 equals()的区别(非常重要)</h2><ol><li><p>== 的使用：</p><ol><li>== 为运算法<ol><li>可以使用在基本数据类型变量和引用数据类型变量中</li><li>可以比较的是基本数据类型变量：比较两个变量保存的数据是否相同</li><li>如果比较的是引用数据类型变量：比较的是两个对象的地址值是否相同(这里需要知道的是，每new一个对象，地址值都是重新赋一个16进制数。特殊的String类中，具体在后面文章)。</li></ol></li></ol></li><li><p>equals()方法的使用：</p><ol><li><p>equals():是一个方法而不是运算法</p><ol><li>所以只能引用数据类型</li></ol></li><li><p>Object类中equals()的定义：</p><ol><li>public boolean equals(Object obj){return this == obj;}   </li><li>Object类中equals()的定义和 == 中引用数据类型的作用相同：比较的是两个对象的地址值是否相同</li></ol></li><li><p>像Strign、Date、File、包装类等都重写了Object类中的equals()方法，所以比较的就不再是地址值是否相同，而是比较的是两个对象的 “实体内容”是否相同</p></li><li><p>通常情况下，我们自定义的类如果使用equals()方法的话，也通常是比较两个对象的实体内容是否相同，所有我们要对Object类中equals()方法进行重写</p></li></ol></li></ol><h2 id="五、重写-override"><a href="#五、重写-override" class="headerlink" title="五、重写(override)"></a>五、重写(override)</h2><h3 id="override的介绍"><a href="#override的介绍" class="headerlink" title="override的介绍"></a>override的介绍</h3><ol><li><p>子类继承父类之后，可以对父类中同名同参数的方法进行覆盖操作</p></li><li><p>覆盖之后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类中的方法</p><h3 id="override的规定："><a href="#override的规定：" class="headerlink" title="override的规定："></a>override的规定：</h3></li><li><p>方法声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常类型{方法体}</p></li><li><p>规定俗称：</p><ol><li><p>子类中的叫重写方法，父类中叫被重写方法</p></li><li><p><font style="background: #ffff55">子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</font></p></li><li><p>子类重写的方法的修饰符不小于父类被重写的方法的权限修饰符（子类的修饰符范围更大）</p><ul><li><font style="background: #ffff55">特殊情况：子类不能重写父类中声明为private权限的方法&lt;/font</li></ul></li><li><p>返回值类型</p><ol><li>父类被重写的方法返回值类型为void，则子类重写发方法返回值类型也必须为void</li><li>父类被重写发方法返回值类型为A，则子类重写的方法返回值类型可以是A类，或者A的子类</li><li>父类被重写的方法的返回值类型是基本数据类型（double），则子类重写的方法的返回值类型必须是相同的基本数据类型（也是double）</li></ol></li><li><p>子类重写的方法抛出的异常类型不大于父类被重写发方法抛出的异常类型</p></li></ol></li><li><p> <font style="background: #ffff55">子类和父类中发同名参数的方法要么都声明为非static的(可以考虑重写)，要么都声明为static(不可以重写)</p></li><li><p><font style="background: #ffff55">构造器是不可以被重写的</font></p><blockquote><p>总结：override和重载(Overloading)不同之处：</p><ol><li>重载只可以在用一个类中实现，而override只可以在子父类中实现</li><li>重载的方法名必须相同，而override不仅方法名必须相同且返回值类型也必须相同</li><li>重载的参数列表不同，而override的参数列表必须相同</li></ol></blockquote><h2 id="六、super关键字"><a href="#六、super关键字" class="headerlink" title="六、super关键字"></a>六、super关键字</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3></li></ol><ul><li>super理解为：父类</li><li>可以调用：属性、方法、构造器</li></ul><h3 id="super调用属性和方法"><a href="#super调用属性和方法" class="headerlink" title="super调用属性和方法"></a>super调用属性和方法</h3><ol><li>可以在子类的方法或构造器中，通过使用”super.属性”或”super.方法名()”的方式，显示的调用父类中声明的属性或方法。但是，通常情况下我们省略’super’关键字</li><li><font color=red>当父类和子类中定义了同名的属性时</font>，我们想要子类中调用父类中声明的属性，<font style="background: #ffff55">则必须使用”super.属性”的方式，表示调用的是父类中声明的属性</font></li><li><font color=red>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时</font>，则<font style="background: #ffff55">必须使用”super.方法()”方法，表示调用的是父类中声明的方法</font></li></ol><h3 id="super调用构造器"><a href="#super调用构造器" class="headerlink" title="super调用构造器"></a>super调用构造器</h3><ol><li>可以在子类的构造器中显示的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li><li>“super(形参列表)”的使用，必须声明在子类构造器的首行！！</li><li><font style="background: #ffff55">在类的构造器中，针对与“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现</font></li><li>在构造器的首行，没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参构造器“super()”</li></ol><h2 id="七、单元测试的方法-了解、但经常会用到"><a href="#七、单元测试的方法-了解、但经常会用到" class="headerlink" title="七、单元测试的方法(了解、但经常会用到)"></a>七、单元测试的方法(了解、但经常会用到)</h2><p><strong>实现步骤(6步)</strong></p><ul><li><pre><code>选中当前工程-右键选择：bulid path - add libraries - Junit 4 - 下一步</code></pre></li><li><p>创建java类，进行单元测试</p><ul><li><font style="background: #ffff55">此时的java类的要求：①此类是public的 ②此类提供公共的无参构造器</font></li></ul></li><li><p>此类中声明单元测试的方法：</p><ul><li><font style="background: #ffff55">此时的单元测试的方法：方法的权限为public，没有返回值（也就是void类型），没有形参</font></li></ul></li><li><p><font style="background: #ffff55">此时单元测试方法上需要声明注解：@Test,并在单元测试类中导入import org.junit.jupiter.api.Test; </font></p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p></li><li><p>写完代码后，左键双击单元测试的方法名。</p></li><li><p>只能用于方法上面，不能用于类</p></li><li><p>说明：</p><ul><li> 如果执行成功没有异常：绿色；失败:红色</li></ul></li></ul><h2 id="八、包装类"><a href="#八、包装类" class="headerlink" title="八、包装类"></a>八、包装类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</li><li>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 </li><li><img src="../imgs/%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt="包装类的图片"></li></ol><h3 id="数据类型、包装类、String三者相互转换"><a href="#数据类型、包装类、String三者相互转换" class="headerlink" title="数据类型、包装类、String三者相互转换"></a>数据类型、包装类、String三者相互转换</h3><blockquote><p>前提介绍：</p><ol><li>基本数据类型包装成包装类的实例 通过包装类的构造器实现： 还可以通过字符串参数构造包装类对象。</li><li>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。意思就是：</li></ol><ul><li>包装类—–&gt;基本数据类型：不需要使用xxxValue();</li><li>基本数据类型—&gt;包装成包装类 不需要通过包装类的构造器实现。看方法：test1();</li><li>类型必须匹配.所以可以把基本数据类型和包装类看成一个整体，然后与字符串相互转换。</li></ul><ol start="3"><li>所以，我们这里就不在整理jdk1.5之前转换方法的方法了。</li></ol></blockquote><pre class=" language-Java"><code class="language-Java">//数据类型、包装类之间的转换@Test    //自动装箱，自动拆箱    public void test1() &#123;        //自动装箱：数据类型 ---->包装类        int num=10;        Integer i=num;        System.out.println(i.toString()+2);                //自动拆箱：包装类 ---->数据类型        int b=i;        System.out.println(b+2);            &#125;//(数据类型、包装类) 和String之间的相互转换    @Test    //基本数据类型、包装类---->字符串类型String,使用String方法中重载的valueof()。    public void test3() &#123;        int i=10;        Integer b=20;        String str=String.valueOf(i);        String str2=String.valueOf(b);               //控制台中出现不了""        System.out.println(str.toString()+1);        System.out.println(str2+1);    &#125;   @Test    //字符串类型String---->基本数据类型、包装类.使用包装类中的parseXxx()方法。方便记忆：这里面的'的'就可以看做为'.'    public void test4() &#123;        String str1="123";        int parseInt = Integer.parseInt(str1);        System.out.println(parseInt+1);    &#125;</code></pre><h2 id="九、static、final关键字"><a href="#九、static、final关键字" class="headerlink" title="九、static、final关键字"></a>九、static、final关键字</h2><h3 id="static介绍"><a href="#static介绍" class="headerlink" title="static介绍"></a>static介绍</h3><ol><li>意思：静态的</li><li>可以用来修饰类的部分成员：属性、方法、代码块、内部类</li><li>修改属性：静态变量(类变量)所有对象都共享了这个静态变量<ol><li>属性：按是否使用static分为静态变量(类变量)和非静态变量(实例变量)</li><li>实例变量：创建了类的多个对象，每个对象都独立拥有一套类中的非静态变量。当修改其中对象的非静态变量之后，不会导致其他对象的相同属性值改变</li><li>静态变量：创建了类的多个对象，多个对象共享同一个静态变量，当通过某个对象修改静态变量之后，会导致其他对象调用静态变量之后，是修改过的</li><li>修改属性的其他说明：<ol><li>随着类的加载而加载，可以通过”类.静态变量（类变量）”的方式调用，不需要创建对象就可以调用类方法。</li><li>优先于对象存在</li><li>修饰的成员，被所有对象所共享</li><li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ol></li><li>图解：<br><img src="../imgs/static%E5%9B%BE.png" alt="static运用图"></li></ol></li><li>static修饰方法<ol><li>随着类的加载而加载 ，可以通过”类.静态方法()”的方式调用，不需要创建对象就可以调用类方法.</li><li><table>   <caption style="background:#ccc">是否可以调用</caption>   <tr>      <td></td>      <td>静态对象</td>      <td>非静态对象</td>   </tr>   <tr>      <td>类</td>      <td>YES</td>      <td>NO</td>   </tr>   <tr>      <td>对象</td>      <td>YES</td>      <td>YES</td>   </tr></table></li><li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li><li>非静态方法中，即可以调用非静态的属性和方法，也可以调用静态中的方法和属性</li></ol></li></ol><blockquote><p>注意点：</p><ul><li>static方法内部不能有this(this指的是当前对象的调用，static方法根本就不需要创建对象)。也不能有super</li><li>static修饰的方法不能被重写</li><li>关于静态属性和方法，我们应该从生命周期角度理解。父–子–儿（角度）</li></ul><ol start="5"><li>开发中，如何确定一个属性是否要声明static类型？</li></ol></blockquote><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同</li></ul><ol start="6"><li>开发中，如何确定一个方法是否要声明static类型？<ul><li>操作静态属性的方法，通常设置为static类型<br>Java中工具类的方法，习惯上声明为static的。比如：Math、Arrays等</li></ul></li></ol><h3 id="final介绍"><a href="#final介绍" class="headerlink" title="final介绍"></a>final介绍</h3><ol><li><p>意思为：最终的，言简意赅，就知道final修饰的任何的东西，都是最后的结果。</p></li><li><p>可以修饰：类、方法、变量</p></li><li><p>修饰类：</p><ol><li>此类不能被其他类所继承了，可以理解为此类是最终类</li><li>比如：String类、System类、StringBuffer类等</li></ol></li><li><p>修饰方法：</p><ol><li>表明此方法不可以重写</li><li>比如：Object类中的getClass();</li></ol></li><li><p>修饰变量</p><ol><li>此时“变量”就会变为一个常量</li><li>修饰属性<ol><li> 可以赋值的位置有：显示初始化、代码块中初始化、构造器中初始化</li></ol></li><li>修饰局部变量<ol><li>法中的局部变量</li><li>形参</li></ol></li></ol></li></ol><blockquote><p>注意：<br>&ensp;尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法，给“常量形参”赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不可以进行重新赋值.</p><ul><li>static final ：用来修饰属性：全局常量</li></ul></blockquote><h2 id="十、抽象类与抽象方法、接口-interface"><a href="#十、抽象类与抽象方法、接口-interface" class="headerlink" title="十、抽象类与抽象方法、接口(interface)"></a>十、抽象类与抽象方法、接口(interface)</h2><h3 id="抽象类、抽象方法"><a href="#抽象类、抽象方法" class="headerlink" title="抽象类、抽象方法"></a>抽象类、抽象方法</h3><ol><li><p>abstract的介绍</p><ol><li><p>意思为：抽象</p></li><li><p>可以修饰：方法、类</p></li><li><p>修饰类：(抽象类)</p><ol><li>此类不可以创建实例化，也就是不能new一个新的对象</li><li>抽象类中一定有构造器，便于子类实例化时调用(涉及：子类对象实例化的全过程)</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，然后完成相关操作</li></ol></li><li><p>修饰方法：(抽象方法)</p><ol><li>抽象方法只有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是抽象类，反之不然，抽象类中可以没有抽象方法</li><li>如子类重写了父类中的所有抽象方法后，此子类就可以实例化，不会报错。如果子类没有重写父类中的所有抽象方法，则子类也是一个抽象类，否则报错<blockquote><p>总结：<br><code>抽象使用的前提：</code></p><ol><li>使用面向对象三个属性中的多态性</li><li>继承性</li></ol><ul><li>abstract基本上都是<code>基于重写</code>方法来实现的</li><li>abstract不能修饰：属性、构造器、代码块等结构</li><li>abstract不能用来修饰私有的方法、静态方法（因为不能被重写）、final类、final方法</li></ul></blockquote></li></ol></li></ol></li></ol><p>相关问题：</p><ul><li>为什么抽象类不可以使用final关键字声明？<ul><li>final修饰的类不能被继承，所有不能有子类。然而抽象类只能被子类所继承，两者相冲突。所以abstract类不能被final修饰。</li></ul></li><li>一个抽象类中可以定义构造器吗？ <ul><li>可以，子类实例化之后，被子类所调用。使用super关键字调用</li></ul></li><li>是否可以这样理解：抽象类就是比普通类多定义了抽象方 法，除了不能直接进行类的实例化操作之外，并没有任何的不同？ <ul><li>可以</li></ul></li></ul><h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h3><ol><li><p>在java中接口使用interface来定义，使用implements去实现接口</p></li><li><p>接口和类是并列的两个结构，且接口是特殊的抽象类，所以抽象类实现接口，不用重写接口中的抽象方法</p></li><li><p>如何定义接口?</p><ol><li>JDK7及之前：<ol><li>全局变量：都默认是由public static final修饰的</li><li>抽象方法都默认是由public abstract修饰的</li></ol></li><li>JDK8：除了定义全局变量和抽象方法之外，还可以定义静态方法、默认方法（default）<ol><li>知识点1：接口中定义的静态方法，只能通过接口来调用</li><li>知识点2：通过实现类的对象，可以调用接口中默认的方法<ol><li>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写之后的方法</li></ol></li><li>知识点3：如果子类（实现类）继承父类和实现接口中声明了同名同参的默认方法，那么子类在没有重写的情况下，默认调用的是父类中同名同参数的方法 —–&gt;类优先原则</li><li>知识点4：如果实现类实现多个接口，而多个接口中有同名同参数的默认方法，那么实现类在没有重写的情况下，报错。—&gt;接口冲突。<ol><li>解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</li></ol></li><li>知识点5：如何在实现类的方法中调用接口中被重写的方法—默认的方法<ol><li>接口名.super.方法名();</li></ol></li><li>接口中没有构造器，意味着接口就不可以创建实例（创建对象）</li><li>接口采用多继承机制。</li></ol></li></ol></li><li><p>java开发中，接口通过 让 类 去 实现(implement) 的 方式 来使用</p><ol><li>如果实现类覆盖了接口中的抽象方法，则此实现类就可以实例化</li><li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类是抽象类</li></ol></li><li><p>java类可以实现多个接口 ——&gt;弥补了java单继承性的局限性</p><ul><li>格式：class SubClass extends SuperClass implements AA,BB,CC,….{ }</li></ul></li><li><p>类与类之间实现继承、类与接口之间使用 实现 implements 。接口和接口也使用继承，不过和类之间不一样，可以多继承。（这是因为接口不可以实例化）</p></li></ol><blockquote><p>总结：接口与抽象类之间的区别</p><table>    <tr>       <td>NO.</td>       <td>区别点</td>       <td>抽象类</td>       <td>接口</td>    </tr>    <tr>       <td>1</td>       <td>定义</td>       <td>包含抽象方法的类</td>       <td>主要是抽象方法和全局常量的集合</td>    </tr><tr>       <td>2</td>       <td>组成</td>       <td>构造方法、抽象方法、普通方法、常量、变量</td>       <td>常量、抽象方法、(JDK8：默认方法、静态方法)</td>    </tr><tr>       <td>3</td>       <td>使用</td>       <td>子类继承抽象类</td>       <td>子类实现接口</td>    </tr><tr>       <td>4</td>       <td>关系</td>       <td>抽象类可以实现多个接口</td>       <td>接口不能继承抽象类，但允许继承多个接口</td>    </tr><tr>       <td>5</td>       <td>对象</td>       <td>都是通过对象的多态性产生实例话的对象</td>       <td>都是通过对象的多态性产生实例话的对象</td>    </tr></table></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> BASIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现十大排序算法</title>
      <link href="/2022/102638641.html"/>
      <url>/2022/102638641.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大经典排序"><a href="#十大经典排序" class="headerlink" title="十大经典排序"></a>十大经典排序</h1><p>&ensp;本学期学了数据结构,为了更好的去理解其中的知识,同时也为了训练自己的相关思想，总而言之，既然花时间去做了这件事，就得有所成果。所以，为了让自己理解的更加透彻，我想把自己所学、所理解的的内容，在此分享给友友们。如果有地方不理解或者有错误，大家可以在本篇文章底部进行评论、私聊我可以。我看到会及时回复大家的。那么好，我们言归正传，下面正式介绍十大算法，因为时间问题，我会分成两篇文章进行介绍。</p><h2 id="一、排序的说明"><a href="#一、排序的说明" class="headerlink" title="一、排序的说明"></a>一、排序的说明</h2><h3 id="1-1-排序的定义"><a href="#1-1-排序的定义" class="headerlink" title="1.1 排序的定义"></a>1.1 排序的定义</h3><p>对一序列对象根据某个关键字进行排序</p><h3 id="1-2-术语说明"><a href="#1-2-术语说明" class="headerlink" title="1.2 术语说明"></a>1.2 术语说明</h3><ul><li>稳定：如果a原本排序在b的前面，而a=b，排序之后a任然在b的前面;</li><li>不稳定：如果如果a原本排序在b的前面，而a=b，排序之后a却在b的后面;</li><li>内排序：所有排序操作都在内存中完成</li><li>外排序：由于数据量太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;</li><li>时间复杂度：一个算法执行所耗费的时间</li><li>空间复杂度：运行完一个程序所需内存的大小<h3 id="1-3-算法的总结"><a href="#1-3-算法的总结" class="headerlink" title="1.3 算法的总结"></a>1.3 算法的总结</h3></li><li><img src="../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="图片理解"></li><li>名词解释：<ul><li>n:数据规模<ul><li> <font style="background:#ff22">解释：运行一个O(n)的程序，观察n对程序运行时间的影响。</font></li></ul></li><li>k:‘桶’的个数<ul><li> ‘桶’的基本了解：它所统计的就是每个数据在数据集合中一共出现了多少次。</li><li> <font style="background:#ff22">这里引用了大佬的比喻：一般的数据结构，就好比有几个篮子(A,B,C)，我们接到了一个新的数据，就要考虑将其按我们想要的那种方式分类，然后扔到某一个篮子里。桶呢？就好比有几个篮子(1,2,3,4)，我们接到了一个新的数据，只看这个数据到底是什么，是1就扔进1号篮，2就扔进2号篮，以此类推。</font></li></ul></li><li> In-place:占用内存，不占用额外的内存</li><li> Out-place:占用额外的内存</li></ul></li></ul><h3 id="1-4-比较和非比较的区别"><a href="#1-4-比较和非比较的区别" class="headerlink" title="1.4 比较和非比较的区别"></a>1.4 比较和非比较的区别</h3><p>&ensp;常见的<em><strong>快速排序、归并排序、堆排序、冒泡排序等</strong></em>属于<font color=red>比较排序</font>。<strong>在排序的最终结果中，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong><br>&ensp;在冒泡排序之类的排序中，问题规模为n，又因为需要比较n此，所以平均时间复杂度为O(n^2)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>&ensp;计数排序、基数排序、桶排序属于非比较排序。<em><strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr,计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置</strong></em>。<br>&ensp;非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p><blockquote><p>总结：<br>&ensp;比较排序的优势是，使用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。<br>&ensp;非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定的要求。</p></blockquote><h2 id="二、十大经典排序一：冒泡排序-Bubble-Sort"><a href="#二、十大经典排序一：冒泡排序-Bubble-Sort" class="headerlink" title="二、十大经典排序一：冒泡排序(Bubble Sort)"></a>二、十大经典排序一：冒泡排序(Bubble Sort)</h2><h3 id="2-1-说明："><a href="#2-1-说明：" class="headerlink" title="2.1 说明："></a>2.1 说明：</h3><p>&ensp;冒泡排序是一种简单的排序算法。它重复走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换。走访数列的工作是重复的进行直到没有在需要交换。此时该数列已经排序完成。</p><h3 id="2-2-算法描述-以升序为例"><a href="#2-2-算法描述-以升序为例" class="headerlink" title="2.2 算法描述(以升序为例)"></a>2.2 算法描述(以升序为例)</h3><ul><li>比较相邻的两个元素。如果第一个比第二个大，就交换它们两。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素会是数组中最大的数。</li><li><font style="background:#abab">针对所有元素重复以上的步骤，此时，除去最后一个</font></li><li>重复上面3步操作，知道排序完成。<h3 id="2-3-动图显示"><a href="#2-3-动图显示" class="headerlink" title="2.3 动图显示"></a>2.3 动图显示</h3><img src="../imgs/%E5%8A%A8%E6%80%81.gif" alt="冒泡排序"><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><pre class=" language-Java"><code class="language-Java">public int[] Bubble(int[] arry)&#123;  //先判断数组中是否有数据      if(arr.length == 0)&#123;              return arr;          &#125;  //这里的i表示比较的趟数       for (int i = 0; i < arry.length; i++) &#123;          //j表示数组下标，因为每次完成一次趟数下一趟就会少一个数进行比较          for (int j = 0; j < arry.length-i-1; j++) &#123;              if(arry[j]>arry[j+1])&#123;                  //temp为临时变量，两个数据之间的交换操作                  int temp=arry[j];                  arry[j]=arry[j+1];                  arry[j+1]=temp;              &#125;          &#125;      &#125;      return arry;  &#125;</code></pre><h3 id="2-5-算法分析"><a href="#2-5-算法分析" class="headerlink" title="2.5 算法分析"></a>2.5 算法分析</h3></li><li>最佳情况：T(n)=O(n)—-&gt;表示一次就成功</li><li>最差情况：T(n)=O(n^2) —–&gt;表示最后才成功</li><li>平均情况：T(n)=O(n^2)</li></ul><h2 id="三、十大经典排序二：选择排序-Selection-Sort"><a href="#三、十大经典排序二：选择排序-Selection-Sort" class="headerlink" title="三、十大经典排序二：选择排序(Selection Sort)"></a>三、十大经典排序二：选择排序(Selection Sort)</h2><h3 id="3-1-说明："><a href="#3-1-说明：" class="headerlink" title="3.1 说明："></a>3.1 说明：</h3><p>&ensp;表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，<font style="background:orange">所以用到它的时候，<strong>数据规模越小越好</strong>。唯一的好处可能就是不占用额外的内存空间。</font><br>&ensp;工作原理：首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。依次类推，直接所有元素均排序完毕。</p><h3 id="3-2-算法描述"><a href="#3-2-算法描述" class="headerlink" title="3.2 算法描述"></a>3.2 算法描述</h3><p>&ensp;n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体描述如下：</p><ul><li>初始状态：无序区[1….n],有序区为空;</li><li>第i(i∈(1,2,3..))趟排序开始时,当前有序区和无序区分别为R[1….i-1]和R[i…n)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第i个记录R交换，使R[1….i-1]和R[i…n)分别变为记录个数增加1个新有序区和记录个数减少1个的新无序区。<h3 id="3-3-动画演示"><a href="#3-3-动画演示" class="headerlink" title="3.3 动画演示"></a>3.3 动画演示</h3><img src="../imgs/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"><h3 id="3-4-代码排序"><a href="#3-4-代码排序" class="headerlink" title="3.4 代码排序"></a>3.4 代码排序</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">Selection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//先判断数组中是否有数据</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> arr<span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//假设，下标为i所对应的值为最小</span>          <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//把最小值的小标赋给minIndex</span>                  minIndex<span class="token operator">=</span>j<span class="token punctuation">;</span>              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//根据下标的对应值进行交换数据</span>          <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//如果下标i后面没有比它小的值，则位置不变，i++</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="3-5-算法分析"><a href="#3-5-算法分析" class="headerlink" title="3.5 算法分析"></a>3.5 算法分析</h3></li><li>最佳情况：T(n)=O(n^2)</li><li>最差情况：T(n)=O(n^2)</li><li>平均情况：T(n)=O(n^2)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础二</title>
      <link href="/2022/102562568.html"/>
      <url>/2022/102562568.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础二"><a href="#Java基础二" class="headerlink" title="Java基础二"></a>Java基础二</h1><h2 id="一、方法重载"><a href="#一、方法重载" class="headerlink" title="一、方法重载"></a>一、方法重载</h2><p><font color=red>定义：</font><br>&emsp;同一个类中，允许存在一个以上同一个方法名的方法，只要他们的<font color=blue>参数个数或参数类型不同</font>就可以。  </p><blockquote><p>总结：方法重载判断(两同一不同)：(类相同、方法名相同、参数(类型、个数)不同)。<br>判断是否是重载：与方法的权限修饰、返回值类型、形参变量名、方法体都没有关系。</p></blockquote><h2 id="二、匿名对象"><a href="#二、匿名对象" class="headerlink" title="二、匿名对象"></a>二、匿名对象</h2><p>理解：  </p><ul><li>创建对象没有显示的赋给一个变量名。即匿名对象。例如：new People();</li><li>调用类中的属性或方法：new People().属性、new People().方法();  </li></ul><p>特征：匿名对象只能调用一次。因为new一个就代表一个对象。  </p><h2 id="三、方法形参的传递机制：值传递"><a href="#三、方法形参的传递机制：值传递" class="headerlink" title="三、方法形参的传递机制：值传递"></a>三、方法形参的传递机制：值传递</h2><p> 1.<font color=red>形参</font>：方法定义时，声明的小括号中的值<br> 2.<font color=red>实参</font>：对象调用时候，实参传递给形参的值为实参</p><h3 id="值传递机制"><a href="#值传递机制" class="headerlink" title="值传递机制"></a>值传递机制</h3><p>1.如果变量为基本数据类型，此时赋值的是变量所保存的数据值<br>2.如果变量是引用数据类型==对象调用，此时赋值的变量所保存的数据的地址值。<br>3.<font style="background: orange">如果参数为基本数据类型，此时实参赋给形参的是实参真实存储的数据值</font><br>4.<font style="background: orange">如果参数是引用数据类型==对象调用，此时赋值的变量所保存的数据的地址值  </font></p><h2 id="四、Recursion-递归-了解"><a href="#四、Recursion-递归-了解" class="headerlink" title="四、Recursion(递归)了解"></a>四、Recursion(递归)了解</h2><ul><li>  递归方法：一个方法体内调用它自身。</li><li>  方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li><li>  递归一定要向已知方向递归，否则这种递归就变成了无穷递归，就是死循环。</li><li>  递归对程序不是一无是处的，相反，递归对训练自己的思维很有帮助</li></ul><h2 id="五、面向对象之一：封装-potting与隐藏"><a href="#五、面向对象之一：封装-potting与隐藏" class="headerlink" title="五、面向对象之一：封装 potting与隐藏"></a>五、面向对象之一：封装 potting与隐藏</h2><p>1.该隐藏的隐藏，该暴露的暴露。这是<font style="background: #5246">封装性的思想</font>  </p><ul><li> <font style="background: #3333">问题引入：<blockquote><p>&ensp;当创建一个类的对象之后，可以通过“对象.属性”方式，对对象的属性进行赋值。这时候，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他限制条件。<br>&ensp;但是在实际生活中，我们需要给属性赋值加入额外的限制条件。这个条件就不能再属性声明时体现。我们只能通过方法进行限制条件的添加。同时，需要避免用户再使用“对象.属性”方式进行赋值。则需要将属性声明为私有的（private）。—&gt;此时，针对于属性就体现了封装性  </p></blockquote></li><li>封装性的体现：<ul><li><font color=red>将类的属性（xxx）私有化（private),同时，提供共有的方法来获取（getXxx）和设置(setXxx)</font></li></ul></li><li>封装性的体现，需要权限修饰符来配合<ul><li>Java中规定4中权限（有小到大）：<font style="background: orange">private、缺省（default）就是省略、protected、public</font></li><li><img src="../imgs/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0.png" alt="权限修饰图范围"></li></ul></li></ul><blockquote><p>总结：<br>1、总结封装性：Java提供了4中权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小<br>2.不建议把set和get的功能写在同一个方法中，因为会发生明知故问这样情况。<br>3、(tips:)eclipse中快捷键设置set和get方法：Alt+Shift+s</p></blockquote><h2 id="六、面向对象之二：继承性"><a href="#六、面向对象之二：继承性" class="headerlink" title="六、面向对象之二：继承性"></a>六、面向对象之二：继承性</h2><p>1.为什么要有继承？  WHY ? What  :  how  </p><ul><li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。 </li><li>Eg:Student类继承了父类Person的所有属性和方法，并增加了一 个属性school。Person中的属性和方法,Student都可以使用。  </li></ul><p>2.继承的好处：</p><ul><li>继承的出现减少了代码冗余，提高了代码的复用性。   </li><li>继承的出现，更有利于功能的扩展。 </li><li>继承的出现让类与类之间产生了关系，提供了多态的前提。<blockquote><p><font style="background:#ffff00">注意：不要仅为了获取其他类中某个功能而去继承，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。</font></p></blockquote></li></ul><p>3.类继承语法规则：</p><ul><li><p>class Student extends Person{}</p><ul><li>Student 为 子类、派生类、subclass</li><li>Person：父类、基类 、超类、superclass</li></ul></li><li><p>体现：</p><ul><li>一旦A类继承B类以后，子类A就获取了父类B中声明的所有属性和方法<br><font style="background:#ffff00">特别的，父类中声明为private的属性或方法，子类继承父类之后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</font></li><li>子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的扩展。<font style="background:#ffff00">子类功能 &gt; 父类功能</font></li></ul></li></ul><p>4.继承性的规定：</p><ul><li><font color="background:#ffff00">Java只支持单继承和多层继承，不允许多重继承</li><li>一个子类只能有一个父类 ：单继承</li><li>一个父类可以派生出多个子类 ：</li><li>子类直接继承父类，称为：直接父类。C→A为：间接父类</li><li>C可以继承所有B和A类的所有方法和属性</font></li></ul><p>5.间接父类图形演示：<br>&emsp;&emsp;&emsp;&emsp;&emsp;<img src="../imgs/%E7%AE%80%E4%BB%8B%E7%88%B6%E7%B1%BB.png" alt="间接父类"></p><h2 id="七、面向对象之三：多态性"><a href="#七、面向对象之三：多态性" class="headerlink" title="七、面向对象之三：多态性"></a>七、面向对象之三：多态性</h2><p>1.理解多态性：<br>可以理解为一个事物的多种形态。就是引用父类的类型调用子类重写父类的方法。  </p><p>2.何为多态：  </p><ul><li>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）。</li><li>Eg:<ul><li>Person p1=new Man();p1（引用）为person类型，子类的对象：new Man()（new了一个对象）</li></ul></li></ul><p>3.多态性的使用：虚拟方法调用</p><ul><li><p>虚拟方法调用：</p><ul><li>子类中定义了与父类同名同参数的方法（重写），在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法 确定的。 </li></ul></li><li><p>有了对象多态以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们实际执行的是子类重写父类的方法。</p><blockquote><p>总结：<strong>编译看左边；运行结果看右边；</strong> </p></blockquote></li></ul><p>4.多态性：<font color="background:#ffff00">只适用于方法，不适用于属性(编译和运行都看左边类的类型)</font></p><p>5.<font color="background:#ffff00">多态性的使用前提：（方法）</font></p><ul><li><font color=red>类的继承关系(子父类关系)</li><li>方法的重写(override)</font></li><li>不能调用子类所特有的方法；编译时，引用是父类的类型，所以必须是重写的方法</li></ul><p>6.多态的使用：<br>&emsp;当调用子父类同名同参数的方法时，实际执行的是子类的重写的方法。  </p><blockquote><p>总结：子类继承父类</p><ul><li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的 同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边，运行在右边.</li><li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的 实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量（因为多态不适用于属性。）所以当子类和父类中有相同的属性名，则引用谁就调用谁的方法。编译运行都看左边</li></ul></blockquote><p>7.instanceof 操作符</p><ul><li>x instanceof A：检验x是否为类A的对象，返回值为boolean型。 </li><li>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 </li><li>如果x属于类A的子类B，x instanceof A值也为true。 </li></ul><p>8.图片理解<br><img src="../imgs/instanceof.png" alt="instanceof"><br>9.向下转型：</p><ul><li>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致了编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。</li><li>如何才能调用子类特有的属性和方法？<ul><li>向下转型：使用强制类型转换符  </li></ul></li></ul><p>10.向上转型（多态）：子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象。</p><h2 id="八、类的成员之三：构造器-构造方法"><a href="#八、类的成员之三：构造器-构造方法" class="headerlink" title="八、类的成员之三：构造器(构造方法)"></a>八、类的成员之三：构造器(构造方法)</h2><h3 id="1、构造器特征以及作用"><a href="#1、构造器特征以及作用" class="headerlink" title="1、构造器特征以及作用"></a>1、构造器特征以及作用</h3><p>1.具有与类相同的名称<br>2.不声明返回值类型。(与声明void不同)<br>3.不能被static、final、synchronized、abstract、native修饰，不能有<br>return语句返回值<br>4.创建对象、给对象进行初始化<br>5.语法格式</p><ul><li>修饰符 类型(参数列表){初始化语句;}</li></ul><h3 id="2、构造器的分类"><a href="#2、构造器的分类" class="headerlink" title="2、构造器的分类"></a>2、构造器的分类</h3><p>1.根据参数不同，构造器可以分为如下两类：</p><ul><li>隐式无参构造器（系统默认提供）</li><li>显式定义一个或多个构造器（无参、有参）</li></ul><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><ul><li>Java语言中，每个类都至少有一个构造器</li><li>默认构造器的修饰符与所属类的修饰符一致</li><li>一旦显式定义了构造器，则系统不再提供默认构造器</li><li>一个类可以创建多个重载的构造器</li><li>父类的构造器不可被子类继承</li></ul><h3 id="4、属性赋值的过程"><a href="#4、属性赋值的过程" class="headerlink" title="4、属性赋值的过程"></a>4、属性赋值的过程</h3><ul><li>赋值的位置：<br>a、默认初始化<br>b、显示初始化<br>c、 构造器中初始化<br>d、 通过”对象.属性”或”对象.方法()”的方式赋值</li><li>赋值的先后顺序<br>a-b-c-d</li></ul><h2 id="九、关键字–this、import、package"><a href="#九、关键字–this、import、package" class="headerlink" title="九、关键字–this、import、package"></a>九、关键字–this、import、package</h2><h3 id="1、this是什么？"><a href="#1、this是什么？" class="headerlink" title="1、this是什么？"></a>1、this是什么？</h3><p>1.<font color=red>它在方法内部使用，即这个方法所属对象的引用；<br>2.它在构造器内部使用，表示该构造器正在初始化的对象。</font></p><h3 id="2、this的作用"><a href="#2、this的作用" class="headerlink" title="2、this的作用"></a>2、this的作用</h3><ul><li>this 可以调用类的属性、方法和构造器</li><li><strong>什么时候使用this关键字呢？</strong><ul><li>当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。</li></ul></li><li><em><strong>下面的段落非常重要，大概率可以帮助你理解this关键字的用法。</strong></em><blockquote><ol><li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this.</li><li><font color="#ff22f">当形参与成员变量同名时，<font style="background:orange">如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</font>。使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。</font> </li><li>this可以作为一个类中构造器相互调用的特殊格式</li></ol></blockquote></li></ul><h3 id="3、this的使用要求："><a href="#3、this的使用要求：" class="headerlink" title="3、this的使用要求："></a>3、this的使用要求：</h3><ol><li>构造器中不能通过”this(形参列表)”的方式调用自身构造器</li><li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了<br>“this(形参列表)”  </li><li>“this(形参列表)”必须声明在类的构造器的首行！</li><li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li></ol><h3 id="4、Package关键字的使用"><a href="#4、Package关键字的使用" class="headerlink" title="4、Package关键字的使用"></a>4、Package关键字的使用</h3><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包属于标识符，遵循标识符的命名规则、规范、“见名知意”</li><li>package命名时候每一个“.”代表一层文件目录<ol><li>补充：<ol><li>同一个包中，不能命名同名的接口、类</li><li>不同包下，可以命名同名的接口、类</li></ol></li></ol></li></ol><h3 id="5、import关键字的使用"><a href="#5、import关键字的使用" class="headerlink" title="5、import关键字的使用"></a>5、import关键字的使用</h3><ol><li>import：导入</li><li>在源文件中显示使用import结构导入指定包下的类、接口</li><li>如果使用的类或接口在本包下面定义的，则可以省略使用import</li><li>如果在源文件中，使用了不同包下的同名类，则必须至少有一个类需要以全名类（包的名字.类的名字）的方式显示</li><li>Import static：导入指定类或接口中的静态方法结构：属性或方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> BASIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础一</title>
      <link href="/2022/102437225.html"/>
      <url>/2022/102437225.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的基本数据类型-两类、8个"><a href="#Java中的基本数据类型-两类、8个" class="headerlink" title="Java中的基本数据类型(两类、8个)"></a>Java中的基本数据类型(两类、8个)</h1><h2 id="数值类型-–-gt-六个"><a href="#数值类型-–-gt-六个" class="headerlink" title="数值类型 –&gt;六个"></a>数值类型 –&gt;六个</h2><p>整型：<br>1.byte(字节型)：内存占1个字节<br>2.short(短整型)：内存占2个字节<br>3.int(整型)：内存占4个字节<br>4.long(长整型)：内存占8个字节<br>浮点型：<br>1.float(单精度浮点型)：内存中占4个字节<br>2.double(双精度浮点型)：内存中占8个字节</p><h2 id="非数值类型-–-gt-两个"><a href="#非数值类型-–-gt-两个" class="headerlink" title="非数值类型 –&gt;两个"></a>非数值类型 –&gt;两个</h2><p>1.char(字符串)：内存中占2个字节<br>2.boolean(布尔型)：boolean类型被编译成int类型来使用时，占4个byte。boolean数组被编译成byte数组，每个boolean数组成员占1个byte(8位)。在Java虚拟机里，00000001表示true，00000000表示false。</p><blockquote><p>注意c语言中的char占用1个字节。<br>提示：int（数值基本类型）类型默认值为：0；boolean类型默认为：false；String默认值为：null；因为String为类，不是基本数据类型（切记）—(具体原因，后期更新!)</p></blockquote><h2 id="一维数组的声明"><a href="#一维数组的声明" class="headerlink" title="一维数组的声明"></a>一维数组的声明</h2><ul><li>int[] 数组名=null；</li><li>int 数组名[]=null；</li><li>int[] 数组名=new int[3]；</li></ul><h2 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h2><ul><li>float[][] numthree; </li><li>numthree=new float[5][5]; </li><li>short[][] numfour=new short[5][8]</li><li>short[][] numfour=new short[5][]</li></ul><h1 id="OOP的三条主线"><a href="#OOP的三条主线" class="headerlink" title="OOP的三条主线"></a>OOP的三条主线</h1><h2 id="一、类及类的成员"><a href="#一、类及类的成员" class="headerlink" title="一、类及类的成员"></a>一、类及类的成员</h2><p>  1.属性：成员变量=field=字段、域<br>  2.方法：函数=成员方法=method<br>  3.构造器<br>  4.内部类<br>  5.代码块</p><h3 id="类和对象的理解，两者之间的关系"><a href="#类和对象的理解，两者之间的关系" class="headerlink" title="类和对象的理解，两者之间的关系"></a>类和对象的理解，两者之间的关系</h3><blockquote><p>类：抽象的、概念上的内容。对象：实实在在存在的一个个体。对象是由类new出来的，每new一个都是一个新的对象。</p></blockquote><h3 id="驼峰式命名"><a href="#驼峰式命名" class="headerlink" title="驼峰式命名"></a>驼峰式命名</h3><blockquote><p>类名的命名、接口名、命名空间等 —–&gt;大驼峰命名法的使用范围(首单词的首字母是否大写,若大写,则是大驼峰命名法)<br>变量名的命名、函数名(方法名)的命名等 —-&gt;小驼峰命名法(构成标识符的首单词的首字母小写,其他单词的首字母都大写)</p></blockquote><blockquote><p>鄙人刚部署好个人博客，四舍五入操作熟练度为0，编写文件内容格式很丑，目前不懂如何美化，并且第一次使用Markdown编辑器感觉很是鸡肋，没办法写出自己想要的效果。日后会寻找办法去改善这种情况。目前本人大三在读，日常分享Java基础知识。多多关注！多多分享！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> BASIC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
